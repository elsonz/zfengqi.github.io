<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Promise · 返屋企的技术宅</title><meta name="description" content="Promise与Deferred相关知识的再阅读与提炼

阅读资料
promise迷你书
We have a problem with promises   (中文版看这里)
化解使用 Promise 时的竞态条件
&lt;a "><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header style="background-image:url(/header-bg.jpg)"><a href="/" class="logo-link"><img src="/avatar.jpeg"></a><p class="info">zhangfengqi</p><p class="profession"><span>tobe 靠谱的 Front-End Developer</span></p><p class="motto">stay curious · stay hungry</p><nav><ul id="navigation"><li><a href="/archives">归档</a></li><li><a href="/about">关于我</a></li></ul></nav><ul class="sn sn-list iconfont"><li class="sn-list-item"><a href="http://weibo.com/jaredzfq" target="_blank" class="sn-list-link icon-weibo"></a></li><li class="sn-list-item"><a href="https://github.com/zfengqi" target="_blank" class="sn-list-link icon-github"></a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Promise</h1><div class="post-meta"><div class="post-time">2016年02月28日</div></div><div class="post-content"><p>Promise与Deferred相关知识的再阅读与提炼<br><a id="more"></a></p>
<blockquote>
<p><strong>阅读资料</strong></p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">promise迷你书</a></p>
<p><a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">We have a problem with promises</a>   <a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="external">(中文版看这里)</a></p>
<p><a href="http://efe.baidu.com/blog/defusing-race-conditions-when-using-promises/" target="_blank" rel="external">化解使用 Promise 时的竞态条件</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">阮老师的jQuery的deferred对象详解</a></p>
</blockquote>
<h2 id="u89E3_u51B3_u7684_u662F_u5F02_u6B65_u5904_u7406_u95EE_u9898_uFF0C_u4F20_u7EDF_u662F_u7528_u56DE_u8C03_u51FD_u6570"><a href="#u89E3_u51B3_u7684_u662F_u5F02_u6B65_u5904_u7406_u95EE_u9898_uFF0C_u4F20_u7EDF_u662F_u7528_u56DE_u8C03_u51FD_u6570" class="headerlink" title="解决的是异步处理问题，传统是用回调函数"></a>解决的是异步处理问题，传统是用回调函数</h2><blockquote>
<p>这和回调函数方式相比有哪些不同之处呢？ 在使用promise进行一步处理的时候，我们必须按照接口规定的方法编写处理代码。<br>也就是说，除promise对象规定的方法(这里的 then 或 catch)以外的方法都是不可以使用的， 而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。<br>这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模式。<br>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化， 这也可以说得上是使用promise的理由之一。</p>
</blockquote>
<h2 id="Promise_u7684_u57FA_u7840_u7528_u6CD5"><a href="#Promise_u7684_u57FA_u7840_u7528_u6CD5" class="headerlink" title="Promise的基础用法"></a>Promise的基础用法</h2><figure class="highlight javascript"><figcaption><span>Promise的基础用法-XHR的promise包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getURL(<span class="string">"xxx"</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(responseText);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。<br>会让这个promise对象立即进入确定（即resolved）状态，但如果还有其他异步操作呢？</p>
<p>Promise.resolve(thenable object)<br>然后会将thenable对象转换成promise对象并返回</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了避免同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定 Promise的then只能使用异步调用方式 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner promise"</span>); <span class="comment">// 1</span></span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer promise"</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// why not 213</span></span><br><span class="line"><span class="comment">// new Promise里面的那个回调函数是同步的？</span></span><br><span class="line"><span class="comment">// 回调函数 != 异步 http://liubin.org/promises-book/#mixed-onready.js</span></span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u4E2A_u5FEB_u6377_u65B9_u6CD5_u7684_u5BF9_u5E94_u5173_u7CFB"><a href="#u51E0_u4E2A_u5FEB_u6377_u65B9_u6CD5_u7684_u5BF9_u5E94_u5173_u7CFB" class="headerlink" title="几个快捷方法的对应关系"></a>几个快捷方法的对应关系</h2><table>
<thead>
<tr>
<th>快捷方法</th>
<th>对应于</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promise.resolve</td>
<td>new Promise(function (resolve) { resolve() })</td>
<td></td>
</tr>
<tr>
<td>Promise.reject</td>
<td>new Promise(function (resolve, reject) { reject() })</td>
<td></td>
</tr>
<tr>
<td>.catch</td>
<td>.then(undefined, onRejected)</td>
<td>IE8下的保留字不能用做属性名，只能用[“catch”]</td>
</tr>
</tbody>
</table>
<h3 id="1-_-catch_u548C-then_u6CA1_u6709_u672C_u8D28_u533A_u522B_uFF0C_u4F46_u8981_u5206_u573A_u5408_u4F7F_u7528"><a href="#1-_-catch_u548C-then_u6CA1_u6709_u672C_u8D28_u533A_u522B_uFF0C_u4F46_u8981_u5206_u573A_u5408_u4F7F_u7528" class="headerlink" title="1. .catch和.then没有本质区别，但要分场合使用"></a>1. <code>.catch</code>和<code>.then</code>没有本质区别，但要分场合使用</h3><figure class="highlight javascript"><figcaption><span>捕获不到错误的onRejected函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onRejected不会被调用</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(throwError, onRejected);</span><br><span class="line"><span class="comment">// 改成这样则会被调用</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(throwError).then(<span class="literal">null</span>, onRejected);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.then 方法中的onRejected参数所指定的回调函数，实际上针对的是其promise对象或者之前的promise对象，而不是针对 .then 方法里面指定的第一个参数，即onFulfilled所指向的对象，所以捕获不到onFulfilled抛出的错误。这也是 then 和 catch 表现不同的原因。</p>
</blockquote>
<h3 id="2-_-then_u548C-done_u7684_u533A_u522B"><a href="#2-_-then_u548C-done_u7684_u533A_u522B" class="headerlink" title="2. .then和.done的区别"></a>2. <code>.then</code>和<code>.done</code>的区别</h3><p>在其他类库里提供了<code>done</code>方法，可以用来代替<code>then</code>，但是ES6 Promises和Promises/A+规范中并没有对<code>done</code>做出规定。<br><figure class="highlight javascript"><figcaption><span>done方法的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span>.prototype.done === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.then(onFulfilled, onRejected).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> error;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从实现代码看出：</p>
<ol>
<li>封装了<code>catch</code>方法的执行，通过<code>setTimeout callback throw error</code>把错误抛出来<br>解决了<code>Promise.resolve(42).then(throwError);</code>忘记了使用catch进行异常处理，而导致错误被吞，不会报错的问题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONPromise</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="built_in">JSON</span>.parse(value));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为promise内部有try catch机制，错误被内部catch捕获了，但没有处理，不会抛出</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">JSONPromise(string).then(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">    conole.log(object); <span class="comment">// console拼写错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>done</code>并不返回promise对象，因此在done之后不能使用<code>catch</code>等方法组成方法链</li>
</ol>
<h2 id="promise_u7684then_u94FE_u5F0F_u64CD_u4F5C"><a href="#promise_u7684then_u94FE_u5F0F_u64CD_u4F5C" class="headerlink" title="promise的then链式操作"></a>promise的then链式操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个方法中 return 的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。<br>return的值会由 Promise.resolve(return的返回值); 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的promise对象。</p>
</blockquote>
<h3 id="u6BCF_u6B21then_u8C03_u7528_u4E4B_u540E_u90FD_u8FD4_u56DE_u4E00_u4E2A_u65B0_u7684Promise_u5BF9_u8C61"><a href="#u6BCF_u6B21then_u8C03_u7528_u4E4B_u540E_u90FD_u8FD4_u56DE_u4E00_u4E2A_u65B0_u7684Promise_u5BF9_u8C61" class="headerlink" title="每次then调用之后都返回一个新的Promise对象"></a>每次then调用之后都返回一个新的Promise对象</h3><blockquote>
<p>从代码上乍一看， aPromise.then(…).catch(…) 像是针对最初的 aPromise 对象进行了一连串的方法链调用。<br>然而实际上不管是 then 还是 catch 方法调用，都返回了一个新的promise对象。<br>也就是说， <code>Promise#then</code> 不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。</p>
</blockquote>
<figure class="highlight javascript"><figcaption><span>Promise链式&非链式的区别</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aPromise = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value);&#125;); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 任意处理</span></span><br><span class="line">        <span class="keyword">return</span> newVar;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 对 `then` 进行 promise chain 方式进行调用</span></span><br><span class="line"><span class="keyword">var</span> bPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2: "</span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 任意处理</span></span><br><span class="line">        <span class="keyword">return</span> newVar;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all_28_29__26amp_3B_Promise-race_28_29"><a href="#Promise-all_28_29__26amp_3B_Promise-race_28_29" class="headerlink" title="Promise.all() &amp; Promise.race()"></a>Promise.all() &amp; Promise.race()</h2><h3 id="1-_Promise-all"><a href="#1-_Promise-all" class="headerlink" title="1. Promise.all"></a>1. Promise.all</h3><p>接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 <code>.then</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([req.comment(), req.posts()]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// [comment, posts]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>得到的数据数组的顺序和传入all的顺序一致</li>
<li>传递给 <code>Promise.all</code> 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的</li>
</ul>
<h3 id="2-_Promise-race"><a href="#2-_Promise-race" class="headerlink" title="2. Promise.race"></a>2. Promise.race</h3><p>只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task1(延迟10ms) task2(延迟20ms)</span></span><br><span class="line"><span class="comment">// 执行时间相同</span></span><br><span class="line"><span class="built_in">Promise</span>.race([req.task1(<span class="number">10</span>), req.task2(<span class="number">20</span>)]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 10 输出最先完成的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然只要有一个Promise不再处于pending态就会进行后续操作，但是并不会取消传进去的其他Promise对象的执行</p>
<blockquote>
<p>在 ES6 Promises 规范中，也没有取消（中断）promise对象执行的概念，我们必须要确保promise最终进入resolve or reject状态之一。也就是说Promise并不适用于 状态 可能会固定不变的处理。也有一些类库提供了对promise进行取消的操作。</p>
</blockquote>
<h2 id="Deferred_28jQuery_29__u4E0E_Promise"><a href="#Deferred_28jQuery_29__u4E0E_Promise" class="headerlink" title="Deferred(jQuery) 与 Promise"></a>Deferred(jQuery) 与 Promise</h2><p>上面用Promise对XHR进行了封装，以下用基于Promise实现的Deferred对象进行的改写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._resolve = resolve;</span><br><span class="line">        <span class="keyword">this</span>._reject = reject;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._resolve.call(<span class="keyword">this</span>.promise, value);</span><br><span class="line">&#125;;</span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._reject.call(<span class="keyword">this</span>.promise, error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            deferred.resolve(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run</span></span><br><span class="line">getURL(<span class="string">"xxx"</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;<span class="built_in">console</span>.error(error)&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u540C"><a href="#u5F02_u540C" class="headerlink" title="异同"></a>异同</h3><ol>
<li>deferred包含了promise，并具有一些改变状态的特权方法；而promise上则没有resolve这些方法（通过参数传进了构造函数）</li>
<li>在Promise一般都会在构造函数中编写主要处理逻辑，对resolve、reject方法进行调用</li>
<li>Deferred则不需要将处理逻辑写成一大块代码用Promise构造函数括起来，只需要先创建deferred对象，可以在任何时机对 resolve、reject 方法进行调用。</li>
</ol>
<blockquote>
<p>换句话说，Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</blockquote>
</div><div class="update-time">更新于：2016年02月28日</div></article></div><div class="side-bar"><div class="widget"><h3 class="widget-title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础/">基础</a></li></ul></div><div class="widget"><h3 class="widget-title">标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul></div></div></section><footer><div class="paginator"><a class="prev"> </a><a href="/2016/01/12/git command/" class="next">下一篇</a></div><div class="copyright"><p>© 2015-2016<span>zhangfengqi.xyz</span></p><span class="theme">Theme based on <a href="https://github.com/pinggod/hexo-theme-apollo" class="theme-url">appolo</a></span><span class="hexo">Powered by <a href="https://hexo.io/">Hexo</a></span></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>