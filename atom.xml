<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[返屋企的技术宅]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://zhangfengqi.xyz/"/>
  <updated>2016-02-27T16:40:19.000Z</updated>
  <id>http://zhangfengqi.xyz/</id>
  
  <author>
    <name><![CDATA[zhangfengqi]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Promise]]></title>
    <link href="http://zhangfengqi.xyz/2016/02/28/javascript/promise/"/>
    <id>http://zhangfengqi.xyz/2016/02/28/javascript/promise/</id>
    <published>2016-02-27T16:00:00.000Z</published>
    <updated>2016-02-27T16:40:19.000Z</updated>
    <content type="html"><![CDATA[<p>Promise与Deferred相关知识的再阅读与提炼<br><a id="more"></a></p>
<blockquote>
<p><strong>阅读资料</strong></p>
<p><a href="http://liubin.org/promises-book/" target="_blank" rel="external">promise迷你书</a></p>
<p><a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">We have a problem with promises</a>   <a href="http://efe.baidu.com/blog/promises-anti-pattern/" target="_blank" rel="external">(中文版看这里)</a></p>
<p><a href="http://efe.baidu.com/blog/defusing-race-conditions-when-using-promises/" target="_blank" rel="external">化解使用 Promise 时的竞态条件</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">阮老师的jQuery的deferred对象详解</a></p>
</blockquote>
<h2 id="u89E3_u51B3_u7684_u662F_u5F02_u6B65_u5904_u7406_u95EE_u9898_uFF0C_u4F20_u7EDF_u662F_u7528_u56DE_u8C03_u51FD_u6570"><a href="#u89E3_u51B3_u7684_u662F_u5F02_u6B65_u5904_u7406_u95EE_u9898_uFF0C_u4F20_u7EDF_u662F_u7528_u56DE_u8C03_u51FD_u6570" class="headerlink" title="解决的是异步处理问题，传统是用回调函数"></a>解决的是异步处理问题，传统是用回调函数</h2><blockquote>
<p>这和回调函数方式相比有哪些不同之处呢？ 在使用promise进行一步处理的时候，我们必须按照接口规定的方法编写处理代码。<br>也就是说，除promise对象规定的方法(这里的 then 或 catch)以外的方法都是不可以使用的， 而不会像回调函数方式那样可以自己自由的定义回调函数的参数，而必须严格遵守固定、统一的编程方式来编写代码。<br>这样，基于Promise的统一接口的做法， 就可以形成基于接口的各种各样的异步处理模式。<br>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化， 这也可以说得上是使用promise的理由之一。</p>
</blockquote>
<h2 id="Promise_u7684_u57FA_u7840_u7528_u6CD5"><a href="#Promise_u7684_u57FA_u7840_u7528_u6CD5" class="headerlink" title="Promise的基础用法"></a>Promise的基础用法</h2><figure class="highlight javascript"><figcaption><span>Promise的基础用法-XHR的promise包装</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(xhr.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getURL(<span class="string">"xxx"</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(responseText);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态方法Promise.resolve(value) 可以认为是 new Promise() 方法的快捷方式。<br>会让这个promise对象立即进入确定（即resolved）状态，但如果还有其他异步操作呢？</p>
<p>Promise.resolve(thenable object)<br>然后会将thenable对象转换成promise对象并返回</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了避免同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定 Promise的then只能使用异步调用方式 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner promise"</span>); <span class="comment">// 1</span></span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer promise"</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// why not 213</span></span><br><span class="line"><span class="comment">// new Promise里面的那个回调函数是同步的？</span></span><br><span class="line"><span class="comment">// 回调函数 != 异步 http://liubin.org/promises-book/#mixed-onready.js</span></span><br></pre></td></tr></table></figure>
<h2 id="u51E0_u4E2A_u5FEB_u6377_u65B9_u6CD5_u7684_u5BF9_u5E94_u5173_u7CFB"><a href="#u51E0_u4E2A_u5FEB_u6377_u65B9_u6CD5_u7684_u5BF9_u5E94_u5173_u7CFB" class="headerlink" title="几个快捷方法的对应关系"></a>几个快捷方法的对应关系</h2><table>
<thead>
<tr>
<th>快捷方法</th>
<th>对应于</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promise.resolve</td>
<td>new Promise(function (resolve) { resolve() })</td>
<td></td>
</tr>
<tr>
<td>Promise.reject</td>
<td>new Promise(function (resolve, reject) { reject() })</td>
<td></td>
</tr>
<tr>
<td>.catch</td>
<td>.then(undefined, onRejected)</td>
<td>IE8下的保留字不能用做属性名，只能用[“catch”]</td>
</tr>
</tbody>
</table>
<h3 id="1-_-catch_u548C-then_u6CA1_u6709_u672C_u8D28_u533A_u522B_uFF0C_u4F46_u8981_u5206_u573A_u5408_u4F7F_u7528"><a href="#1-_-catch_u548C-then_u6CA1_u6709_u672C_u8D28_u533A_u522B_uFF0C_u4F46_u8981_u5206_u573A_u5408_u4F7F_u7528" class="headerlink" title="1. .catch和.then没有本质区别，但要分场合使用"></a>1. <code>.catch</code>和<code>.then</code>没有本质区别，但要分场合使用</h3><figure class="highlight javascript"><figcaption><span>捕获不到错误的onRejected函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// onRejected不会被调用</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(throwError, onRejected);</span><br><span class="line"><span class="comment">// 改成这样则会被调用</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(throwError).then(<span class="literal">null</span>, onRejected);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.then 方法中的onRejected参数所指定的回调函数，实际上针对的是其promise对象或者之前的promise对象，而不是针对 .then 方法里面指定的第一个参数，即onFulfilled所指向的对象，所以捕获不到onFulfilled抛出的错误。这也是 then 和 catch 表现不同的原因。</p>
</blockquote>
<h3 id="2-_-then_u548C-done_u7684_u533A_u522B"><a href="#2-_-then_u548C-done_u7684_u533A_u522B" class="headerlink" title="2. .then和.done的区别"></a>2. <code>.then</code>和<code>.done</code>的区别</h3><p>在其他类库里提供了<code>done</code>方法，可以用来代替<code>then</code>，但是ES6 Promises和Promises/A+规范中并没有对<code>done</code>做出规定。<br><figure class="highlight javascript"><figcaption><span>done方法的实现</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span>.prototype.done === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.then(onFulfilled, onRejected).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> error;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从实现代码看出：</p>
<ol>
<li>封装了<code>catch</code>方法的执行，通过<code>setTimeout callback throw error</code>把错误抛出来<br>解决了<code>Promise.resolve(42).then(throwError);</code>忘记了使用catch进行异常处理，而导致错误被吞，不会报错的问题</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONPromise</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="built_in">JSON</span>.parse(value));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为promise内部有try catch机制，错误被内部catch捕获了，但没有处理，不会抛出</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">"&#123;&#125;"</span>;</span><br><span class="line">JSONPromise(string).then(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line">    conole.log(object); <span class="comment">// console拼写错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>done</code>并不返回promise对象，因此在done之后不能使用<code>catch</code>等方法组成方法链</li>
</ol>
<h2 id="promise_u7684then_u94FE_u5F0F_u64CD_u4F5C"><a href="#promise_u7684then_u94FE_u5F0F_u64CD_u4F5C" class="headerlink" title="promise的then链式操作"></a>promise的then链式操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleUp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">promise</span><br><span class="line">    .then(increment)</span><br><span class="line">    .then(doubleUp)</span><br><span class="line">    .then(output)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// promise chain中出现异常的时候会被调用</span></span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个方法中 return 的值不仅只局限于字符串或者数值类型，也可以是对象或者promise对象等复杂类型。<br>return的值会由 Promise.resolve(return的返回值); 进行相应的包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的promise对象。</p>
</blockquote>
<h3 id="u6BCF_u6B21then_u8C03_u7528_u4E4B_u540E_u90FD_u8FD4_u56DE_u4E00_u4E2A_u65B0_u7684Promise_u5BF9_u8C61"><a href="#u6BCF_u6B21then_u8C03_u7528_u4E4B_u540E_u90FD_u8FD4_u56DE_u4E00_u4E2A_u65B0_u7684Promise_u5BF9_u8C61" class="headerlink" title="每次then调用之后都返回一个新的Promise对象"></a>每次then调用之后都返回一个新的Promise对象</h3><blockquote>
<p>从代码上乍一看， aPromise.then(…).catch(…) 像是针对最初的 aPromise 对象进行了一连串的方法链调用。<br>然而实际上不管是 then 还是 catch 方法调用，都返回了一个新的promise对象。<br>也就是说， <code>Promise#then</code> 不仅仅是注册一个回调函数那么简单，它还会将回调函数的返回值进行变换，创建并返回一个promise对象。</p>
</blockquote>
<figure class="highlight javascript"><figcaption><span>Promise链式&非链式的区别</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aPromise = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span>&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value);&#125;); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 任意处理</span></span><br><span class="line">        <span class="keyword">return</span> newVar;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 对 `then` 进行 promise chain 方式进行调用</span></span><br><span class="line"><span class="keyword">var</span> bPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2: "</span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 任意处理</span></span><br><span class="line">        <span class="keyword">return</span> newVar;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-all_28_29__26amp_3B_Promise-race_28_29"><a href="#Promise-all_28_29__26amp_3B_Promise-race_28_29" class="headerlink" title="Promise.all() &amp; Promise.race()"></a>Promise.all() &amp; Promise.race()</h2><h3 id="1-_Promise-all"><a href="#1-_Promise-all" class="headerlink" title="1. Promise.all"></a>1. Promise.all</h3><p>接收一个<strong>promise对象的数组</strong>作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 <code>.then</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([req.comment(), req.posts()]).then(<span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// [comment, posts]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>得到的数据数组的顺序和传入all的顺序一致</li>
<li>传递给 <code>Promise.all</code> 的promise并不是一个个的顺序执行的，而是同时开始、并行执行的</li>
</ul>
<h3 id="2-_Promise-race"><a href="#2-_Promise-race" class="headerlink" title="2. Promise.race"></a>2. Promise.race</h3><p>只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task1(延迟10ms) task2(延迟20ms)</span></span><br><span class="line"><span class="comment">// 执行时间相同</span></span><br><span class="line"><span class="built_in">Promise</span>.race([req.task1(<span class="number">10</span>), req.task2(<span class="number">20</span>)]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 10 输出最先完成的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>虽然只要有一个Promise不再处于pending态就会进行后续操作，但是并不会取消传进去的其他Promise对象的执行</p>
<blockquote>
<p>在 ES6 Promises 规范中，也没有取消（中断）promise对象执行的概念，我们必须要确保promise最终进入resolve or reject状态之一。也就是说Promise并不适用于 状态 可能会固定不变的处理。也有一些类库提供了对promise进行取消的操作。</p>
</blockquote>
<h2 id="Deferred_28jQuery_29__u4E0E_Promise"><a href="#Deferred_28jQuery_29__u4E0E_Promise" class="headerlink" title="Deferred(jQuery) 与 Promise"></a>Deferred(jQuery) 与 Promise</h2><p>上面用Promise对XHR进行了封装，以下用基于Promise实现的Deferred对象进行的改写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._resolve = resolve;</span><br><span class="line">        <span class="keyword">this</span>._reject = reject;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._resolve.call(<span class="keyword">this</span>.promise, value);</span><br><span class="line">&#125;;</span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._reject.call(<span class="keyword">this</span>.promise, error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            deferred.resolve(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send();</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run</span></span><br><span class="line">getURL(<span class="string">"xxx"</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;<span class="built_in">console</span>.error(error)&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="u5F02_u540C"><a href="#u5F02_u540C" class="headerlink" title="异同"></a>异同</h3><ol>
<li>deferred包含了promise，并具有一些改变状态的特权方法；而promise上则没有resolve这些方法（通过参数传进了构造函数）</li>
<li>在Promise一般都会在构造函数中编写主要处理逻辑，对resolve、reject方法进行调用</li>
<li>Deferred则不需要将处理逻辑写成一大块代码用Promise构造函数括起来，只需要先创建deferred对象，可以在任何时机对 resolve、reject 方法进行调用。</li>
</ol>
<blockquote>
<p>换句话说，Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>Promise与Deferred相关知识的再阅读与提炼<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/tags/javascript/"/>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Pro Git》 读书笔记1]]></title>
    <link href="http://zhangfengqi.xyz/2016/01/12/git%20command/"/>
    <id>http://zhangfengqi.xyz/2016/01/12/git command/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-01-20T17:07:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="git_config"><a href="#git_config" class="headerlink" title="git config"></a>git config</h2><h4 id="1-config_file__u6709_u4EE5_u4E0B_u51E0_u79CD"><a href="#1-config_file__u6709_u4EE5_u4E0B_u51E0_u79CD" class="headerlink" title="1.config file 有以下几种"></a>1.config file 有以下几种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Config file location&#10;    --global              use global config file&#10;    --system              use system config file&#10;    --local               use repository config file&#10;    -f, --file &#60;file&#62;     use given config file&#10;    --blob &#60;blob-id&#62;      read config from given blob object</span><br></pre></td></tr></table></figure>
<h4 id="2-_u6709_u4EE5_u4E0B_u51E0_u79CD_u884C_u4E3A_uFF08action_uFF09_u6307_u4EE4_uFF0C_u914D_u5408Config_file_location_uFF0C_u7528_u6765_u589E_u5220_u6539_u67E5_u4E0D_u540C_u7684_u914D_u7F6E_u6587_u4EF6"><a href="#2-_u6709_u4EE5_u4E0B_u51E0_u79CD_u884C_u4E3A_uFF08action_uFF09_u6307_u4EE4_uFF0C_u914D_u5408Config_file_location_uFF0C_u7528_u6765_u589E_u5220_u6539_u67E5_u4E0D_u540C_u7684_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="2.有以下几种行为（action）指令，配合Config file location，用来增删改查不同的配置文件"></a>2.有以下几种行为（action）指令，配合<code>Config file location</code>，用来增删改查不同的配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Action&#10;    --get                 get value: name [value-regex]&#10;    --get-all             get all values: key [value-regex]&#10;    --get-regexp          get values for regexp: name-regex [value-regex]&#10;    --get-urlmatch        get value specific for the URL: section[.var] URL&#10;    --replace-all         replace all matching variables: name value [value_regex]&#10;    --add                 add a new variable: name value&#10;    --unset               remove a variable: name [value-regex]&#10;    --unset-all           remove all matches: name [value-regex]&#10;    --rename-section      rename section: old-name new-name&#10;    --remove-section      remove a section: name&#10;    -l, --list            list all&#10;    -e, --edit            open an editor&#10;    --get-color           find the color configured: slot [default]&#10;    --get-colorbool       find the color setting: slot [stdout-is-tty]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --global --edit // 打开编辑器修改global配置文件</span><br><span class="line">git --global --list // 列出该配置文件中的所有配置信息</span><br></pre></td></tr></table></figure>
<h4 id="3-_u8BBE_u7F6Ekey_value_u7684_u65B9_u5F0F_uFF0C-add_u53EF_u4EE5_u7701_u7565_uFF0C_u5982_u679C_u4E0D_u52A0Config_file_location_u914D_u7F6E_u9879_u7684_u8BDD_uFF0C_u9ED8_u8BA4_u662F_u4FDD_u5B58_u5230-local"><a href="#3-_u8BBE_u7F6Ekey_value_u7684_u65B9_u5F0F_uFF0C-add_u53EF_u4EE5_u7701_u7565_uFF0C_u5982_u679C_u4E0D_u52A0Config_file_location_u914D_u7F6E_u9879_u7684_u8BDD_uFF0C_u9ED8_u8BA4_u662F_u4FDD_u5B58_u5230-local" class="headerlink" title="3.设置key value的方式，--add可以省略，如果不加Config file location配置项的话，默认是保存到--local"></a>3.设置key value的方式，<code>--add</code>可以省略，如果不加<code>Config file location</code>配置项的话，默认是保存到<code>--local</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --add user.age <span class="number">25</span></span><br><span class="line">git config user.xxx <span class="string">"hehehe"</span></span><br><span class="line">git config --global user.name <span class="string">"zhangfengqi"</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_u4E3A_u5E38_u7528_u547D_u4EE4_u8BBE_u7F6E_u522B_u540Dalias"><a href="#4-_u4E3A_u5E38_u7528_u547D_u4EE4_u8BBE_u7F6E_u522B_u540Dalias" class="headerlink" title="4.为常用命令设置别名alias"></a>4.为常用命令设置别名<code>alias</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br><span class="line"></span><br><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD --'</span></span><br><span class="line">// 下面两者等同</span><br><span class="line">$ git unstage fileA</span><br><span class="line">$ git reset HEAD -- fileA</span><br></pre></td></tr></table></figure>
<p>想要执行外部命令，而不是一个Git子命令，需要在命令前面加入<code>!</code>符号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.visual <span class="string">'!gitk'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h2><p>忽略某些后缀的文件，只需要修改<code>.gitignore</code>，将其添加进去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line">*.swp</span><br><span class="line">*.a</span><br><span class="line">!lib.a // 忽略所有.a后缀，但是lib.a除外！</span><br></pre></td></tr></table></figure>
<p>文件 .gitignore 的格式规范如下：</p>
<ol>
<li><p>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</p>
</li>
<li><p>可以使用标准的 glob 模式匹配。</p>
</li>
<li><p>匹配模式可以以（/）开头防止递归。</p>
</li>
<li><p>匹配模式可以以（/）结尾指定目录。</p>
</li>
<li><p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p>
</li>
</ol>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（<em>) 匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（</em>) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># but do track lib.a, even though you're ignoring .a files above</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/github/gitignore" target="_blank" rel="external">A collection of .gitignore templates</a></p>
<h2 id="level_11_12_git_rm"><a href="#level_11_12_git_rm" class="headerlink" title="level 11 12 git rm"></a>level 11 12 git rm</h2><p><a href="http://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#Removing-Files" target="_blank" rel="external">http://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#Removing-Files</a></p>
<ol>
<li><p>将文件从暂存区移除，并且连带从硬盘工作目录中删除</p>
</li>
<li><p>如果仅仅用rm把文件从硬盘中删除，则在git中会出现未暂存记录，这时需要再执行<code>git rm xxx</code> 记录这次删除文件的操作，下一次提交时，该文件就不再纳入版本管理了。</p>
</li>
<li><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p>
</li>
<li><p>只想把文件从暂存区中删除（意味着不再让git跟踪），但不删除保留在硬盘中。<br>使用场景：当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached deleteme.rb // 保存working tree的文件，只从stage中移除，并不再追踪</span><br></pre></td></tr></table></figure>
<h2 id="level_13_14_git_mv"><a href="#level_13_14_git_mv" class="headerlink" title="level 13 14 git mv"></a>level 13 14 git mv</h2><h4 id="1-__u6539_u540D_git_mv_oldfile-txt_newfile-txt"><a href="#1-__u6539_u540D_git_mv_oldfile-txt_newfile-txt" class="headerlink" title="1. 改名 git mv oldfile.txt newfile.txt"></a>1. 改名 <code>git mv oldfile.txt newfile.txt</code></h4><p>其实，运行 git mv 就相当于运行了下面三条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure></p>
<h4 id="2-__u526A_u5207_u6587_u4EF6"><a href="#2-__u526A_u5207_u6587_u4EF6" class="headerlink" title="2. 剪切文件"></a>2. 剪切文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Make a new folder named src, and move all of the .html files into this folder</span><br><span class="line">git mv *.html src/</span><br></pre></td></tr></table></figure>
<h2 id="level_18_git_push"><a href="#level_18_git_push" class="headerlink" title="level 18 git push"></a>level 18 git push</h2><p><a href="https://git-scm.com/docs/git-push" target="_blank" rel="external">https://git-scm.com/docs/git-push</a></p>
<ul>
<li>git push –tags</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// git push origin HEAD</span><br><span class="line">A handy way to push the current branch to the same name on the remote.</span><br></pre></td></tr></table></figure>
<h2 id="git_commit__u2013amend__u4FEE_u6539_u6700_u540E_u4E00_u6B21_u63D0_u4EA4"><a href="#git_commit__u2013amend__u4FEE_u6539_u6700_u540E_u4E00_u6B21_u63D0_u4EA4" class="headerlink" title="git commit –amend 修改最后一次提交"></a>git commit –amend 修改最后一次提交</h2><h4 id="1-__u4FEE_u6539_u6700_u540E_u4E00_u6B21_u7684_u63D0_u4EA4_u4FE1_u606F"><a href="#1-__u4FEE_u6539_u6700_u540E_u4E00_u6B21_u7684_u63D0_u4EA4_u4FE1_u606F" class="headerlink" title="1. 修改最后一次的提交信息"></a>1. 修改最后一次的提交信息</h4><p>直接输入<code>git commit --amend</code>，会被带入编辑器进行提交信息修改</p>
<h4 id="2-__u4E00_u6B21_u63D0_u4EA4_u5DF2_u5B8C_u6210_uFF0C_u4F46_u6709_u4E2A_u6587_u4EF6_u5FD8_u63D0_u8FDB_u53BB_u4E86"><a href="#2-__u4E00_u6B21_u63D0_u4EA4_u5DF2_u5B8C_u6210_uFF0C_u4F46_u6709_u4E2A_u6587_u4EF6_u5FD8_u63D0_u8FDB_u53BB_u4E86" class="headerlink" title="2. 一次提交已完成，但有个文件忘提进去了"></a>2. 一次提交已完成，但有个文件忘提进去了</h4><p>通过修改文件然后运行 <code>git add</code> 或 <code>git rm</code> 一个已追踪的文件，随后运行 <code>git commit --amend</code>拿走当前的暂存区域并使其做为新提交的快照。</p>
<blockquote>
<p><strong>注意顶</strong><br>因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基 - 如果已经推送了最后一次提交就不要修正它。</p>
</blockquote>
<h2 id="git_status__5B-s__7C__u2013short_5D"><a href="#git_status__5B-s__7C__u2013short_5D" class="headerlink" title="git status [-s | –short]"></a>git status [-s | –short]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status <span class="operator">-s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 你可能注意到了 M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。 而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<h2 id="git_diff__26amp_3B_git_difftool"><a href="#git_diff__26amp_3B_git_difftool" class="headerlink" title="git diff &amp; git difftool"></a>git diff &amp; git difftool</h2><ol>
<li><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff<br>请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。</p>
</li>
<li><p>若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的，但更好记些。）</p>
</li>
<li><p>git diff 查看各个区(工作区 暂存区 版本库)之间的差异</p>
<blockquote>
<p><code>git diff</code> 比较的是工作区和暂存区的差别<br><code>git diff –cached</code> 比较的是暂存区和版本库的差别<br><code>git diff HEAD</code> 可以查看工作区和版本库的差别<br>每次commit后,<code>git diff –cached</code>没有内容，是因为暂存区的内容已经更新到版本库中，因此暂存区和版本库中的内容无差别</p>
</blockquote>
</li>
<li><p>git diff的插件版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git difftool --tool-help // 看你的系统支持哪些 Git Diff 插件</span><br><span class="line">git config --global diff.tool vimdiff</span><br><span class="line">git difftool --edit vimdiff</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="git_log__u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#git_log__u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="git log 查看提交历史"></a>git log 查看提交历史</h2><h4 id="1-__u9ED8_u8BA4_u60C5_u51B5_uFF08_u4E0D_u52A0_u4EFB_u4F55_u53C2_u6570_uFF09"><a href="#1-__u9ED8_u8BA4_u60C5_u51B5_uFF08_u4E0D_u52A0_u4EFB_u4F55_u53C2_u6570_uFF09" class="headerlink" title="1. 默认情况（不加任何参数）"></a>1. 默认情况（不加任何参数）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Sat Mar <span class="number">15</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">28</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>
<p>按提交时间列出所有的更新，最近的更新排在最上面。加入参数<code>-p</code>可以看到每次提交的内容差异</p>
<h4 id="2-__u7B80_u5355_u5B9A_u5236_u8F93_u51FA_u5185_u5BB9_-pretty_3Doneline__7C_short__7C_full__7C_fuller"><a href="#2-__u7B80_u5355_u5B9A_u5236_u8F93_u51FA_u5185_u5BB9_-pretty_3Doneline__7C_short__7C_full__7C_fuller" class="headerlink" title="2. 简单定制输出内容 --pretty=oneline | short | full | fuller"></a>2. 简单定制输出内容 <code>--pretty=oneline | short | full | fuller</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline // 只有commit号和comment</span><br><span class="line"><span class="number">4</span>df268a7256494563ff21feeb245a5fb52e42709 m_school bug fixed1</span><br><span class="line">a1f8f9f33ffa4a39d99a0325e92acd73a48e11fa agent phone</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=short // 没有提交时间，是merge的提交会有简明提示</span><br><span class="line">commit <span class="number">7</span>e65491f3f742c3dd3befccd01f74d60d1000c19</span><br><span class="line">Author: zuoerdong</span><br><span class="line"></span><br><span class="line">    redian index, brief content trim space and substr to length <span class="number">100</span></span><br><span class="line"></span><br><span class="line">commit de7042ce4004d8207d3aa4f768d076402ccc972c</span><br><span class="line">Merge: <span class="number">4</span>f0513c <span class="number">448</span>fdf7</span><br><span class="line">Author: Wang Chunwei</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --pretty=full // 作者和提交者都会列出来，还是没有提交时间</span><br><span class="line">commit <span class="number">4</span>df268a7256494563ff21feeb245a5fb52e42709</span><br><span class="line">Author: Zhang Fengqi &lt;zhangfengqi@xxx.com&gt;</span><br><span class="line">Commit: Zhang Fengqi &lt;zhangfengqi@xxx.com&gt;</span><br><span class="line"></span><br><span class="line">    m_school bug fixed1</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=fuller // 多了时间</span><br><span class="line">commit <span class="number">4</span>df268a7256494563ff21feeb245a5fb52e42709</span><br><span class="line">Author:     Zhang Fengqi &lt;zhangfengqi@xxx.com&gt;</span><br><span class="line">AuthorDate: Fri Jan <span class="number">15</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">23</span> <span class="number">2016</span> +<span class="number">0800</span></span><br><span class="line">Commit:     Zhang Fengqi &lt;zhangfengqi@xxx.com&gt;</span><br><span class="line">CommitDate: Fri Jan <span class="number">15</span> <span class="number">18</span>:<span class="number">28</span>:<span class="number">23</span> <span class="number">2016</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    m_school bug fixed1</span><br></pre></td></tr></table></figure>
<h4 id="3-__u9AD8_u5EA6_u5B9A_u5236_u8F93_u51FA_u5185_u5BB9_-pretty_3Dformat_3A_26quot_3Bxxx_26quot_3B"><a href="#3-__u9AD8_u5EA6_u5B9A_u5236_u8F93_u51FA_u5185_u5BB9_-pretty_3Dformat_3A_26quot_3Bxxx_26quot_3B" class="headerlink" title="3. 高度定制输出内容 --pretty=format:&quot;xxx&quot;"></a>3. 高度定制输出内容 <code>--pretty=format:&quot;xxx&quot;</code></h4><p><code>alias.hist=log --pretty=format:&quot;%h %ad | %s%d [%an]&quot; --graph --date=short</code></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%h</td>
<td>commit的短哈希，大写H则为完整哈希</td>
</tr>
<tr>
<td>%t</td>
<td>tree的短哈希，同上</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）名字</td>
</tr>
<tr>
<td>%ae</td>
<td>anthor email</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>relative date 按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<p><code>%ar</code>等同于<code>--date=relative</code>或者<code>--relative-date</code></p>
<h4 id="4-__u9650_u5B9A_u8F93_u51FA_u957F_u5EA6_u548C_u5185_u5BB9"><a href="#4-__u9650_u5B9A_u8F93_u51FA_u957F_u5EA6_u548C_u5185_u5BB9" class="headerlink" title="4. 限定输出长度和内容"></a>4. 限定输出长度和内容</h4><ul>
<li>想获取多个限制条件的并集时，需要添加<code>--all-match</code>选项，否则满足任意一个条件的提交都会被匹配出来</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-(n)</code></td>
<td>仅显示最近的n条提交</td>
</tr>
<tr>
<td><code>--since</code> 或 <code>--after</code></td>
<td>仅显示指定时间之后的提交</td>
<td><code>--since=&quot;2016-01-01&quot; or &quot;1 month 1 day 9 hours ago&quot;</code></td>
</tr>
<tr>
<td><code>--until</code> 或 <code>--before</code></td>
<td>仅显示指定时间之前的提交</td>
<td></td>
</tr>
<tr>
<td><code>--anthor</code></td>
<td>指定作者</td>
<td></td>
</tr>
<tr>
<td><code>--commiter</code></td>
<td>指定提交者</td>
<td></td>
</tr>
<tr>
<td><code>--grep</code></td>
<td>匹配提交说明中的关键字</td>
<td><code>--grep=gulp</code> <code>--grep=&quot;initial commit&quot;</code></td>
</tr>
<tr>
<td><code>--S</code></td>
<td>仅显示添加或移除了某个关键字的提交</td>
<td><code>--Sfunction_named</code></td>
</tr>
</tbody>
</table>
<h4 id="5-__u5176_u4ED6_u9009_u9879"><a href="#5-__u5176_u4ED6_u9009_u9879" class="headerlink" title="5. 其他选项"></a>5. 其他选项</h4><ul>
<li><code>--decorate</code><br>命令查看各个分支当前所指的commit对象</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line"><span class="number">4</span>df268a (HEAD, origin/master, origin/HEAD, master) m_school bug fixed1</span><br><span class="line">a1f8f9f agent phone</span><br></pre></td></tr></table></figure>
<h2 id="u8FDC_u7A0B_u4ED3_u5E93"><a href="#u8FDC_u7A0B_u4ED3_u5E93" class="headerlink" title="远程仓库"></a>远程仓库</h2><h2 id="git_tag"><a href="#git_tag" class="headerlink" title="git tag"></a>git tag</h2><p>两种类型的标签：轻量标签（lightweight）与附注标签（annotated）</p>
<h4 id="1-__u9644_u6CE8_u6807_u7B7E"><a href="#1-__u9644_u6CE8_u6807_u7B7E" class="headerlink" title="1. 附注标签"></a>1. 附注标签</h4><p>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；通常建议创建附注标签。</p>
<p>使用<code>-a</code>,a for annotated.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="operator">-a</span> v1.<span class="number">4</span> -m <span class="string">'my version 1.4'</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.<span class="number">1</span></span><br><span class="line">v1.<span class="number">3</span></span><br><span class="line">v1.<span class="number">4</span></span><br><span class="line"></span><br><span class="line">// 查看标签的详细信息</span><br><span class="line">$ git show v1.<span class="number">4</span></span><br><span class="line">tag v1.<span class="number">4</span></span><br><span class="line">Tagger: Ben Straub &lt;ben@straub.cc&gt;</span><br><span class="line">Date:   Sat May <span class="number">3</span> <span class="number">20</span>:<span class="number">19</span>:<span class="number">12</span> <span class="number">2014</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">my version <span class="number">1.4</span></span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gee-mail.com&gt;</span><br><span class="line">Date:   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span></span><br><span class="line"></span><br><span class="line">    changed the version number</span><br></pre></td></tr></table></figure></p>
<h4 id="2-_u8F7B_u91CF_u6807_u7B7E"><a href="#2-_u8F7B_u91CF_u6807_u7B7E" class="headerlink" title="2.轻量标签"></a>2.轻量标签</h4><p>不保存任何相关信息，只是一个特定提交的引用，轻量标签本质上是将提交校验和存储到一个文件中，然后做个map对应。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 不需要任何其他参数，也不需要写comment</span><br><span class="line">$ git tag v1.<span class="number">4</span>-lw</span><br><span class="line">$ git tag</span><br><span class="line">v0.<span class="number">1</span></span><br><span class="line">v1.<span class="number">3</span></span><br><span class="line">v1.<span class="number">4</span></span><br><span class="line">v1.<span class="number">4</span>-lw</span><br><span class="line">v1.<span class="number">5</span></span><br><span class="line"></span><br><span class="line">// 假设v1.<span class="number">4</span>的commit号为ca82a6，下面两者等同，不会有额外的标签信息</span><br><span class="line">$ git show v1.<span class="number">4</span></span><br><span class="line">$ git show ca82a6</span><br></pre></td></tr></table></figure>
<h4 id="3-_u5BF9_u5DF2_u6709_u7684_u63D0_u4EA4_u6253tag"><a href="#3-_u5BF9_u5DF2_u6709_u7684_u63D0_u4EA4_u6253tag" class="headerlink" title="3.对已有的提交打tag"></a>3.对已有的提交打tag</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="operator">-a</span> v1.<span class="number">2</span> <span class="number">9</span>fceb02</span><br></pre></td></tr></table></figure>
<h4 id="4-_u63A8_u9001_u6807_u7B7E_u5230_u8FDC_u7A0B"><a href="#4-_u63A8_u9001_u6807_u7B7E_u5230_u8FDC_u7A0B" class="headerlink" title="4.推送标签到远程"></a>4.推送标签到远程</h4><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.<span class="number">5</span></span><br><span class="line">$ git push origin --tags // 推送所有不在远程仓库上的标签</span><br></pre></td></tr></table></figure></p>
<h4 id="5-_u5728_u67D0_u4E2Atag_u57FA_u7840_u4E0A_u5EFA_u5206_u652F"><a href="#5-_u5728_u67D0_u4E2Atag_u57FA_u7840_u4E0A_u5EFA_u5206_u652F" class="headerlink" title="5.在某个tag基础上建分支"></a>5.在某个tag基础上建分支</h4><p><code>git checkout -b [branchname] [tagname]</code></p>
<h2 id="git_reset__26amp_3B_git_checkout"><a href="#git_reset__26amp_3B_git_checkout" class="headerlink" title="git reset &amp; git checkout"></a>git reset &amp; git checkout</h2><blockquote>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="external">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86</a></p>
</blockquote>
<h4 id="1-__u4E09_u4E2A_u533A"><a href="#1-__u4E09_u4E2A_u533A" class="headerlink" title="1. 三个区"></a>1. 三个区</h4><table>
<thead>
<tr>
<th>树</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>指向上一次提交的快照，下一次提交的父结点</td>
</tr>
<tr>
<td>Index(暂存区)</td>
<td>预期的下一次提交的快照，add操作之后所放置的区域，当你运行<code>git commit</code>时 Git 看起来的样子</td>
</tr>
<tr>
<td>working Directory</td>
<td>硬盘本地工作目录，沙盒</td>
</tr>
</tbody>
</table>
<ul>
<li><code>git init</code>执行之后只有工作目录有文件1.js(v1)</li>
<li><code>git add 1.js</code>后现在暂存区和工作目录有1.js(v1)，HEAD里没有</li>
<li><code>git commit</code>之后，现在三个区中的文件才是一致的，1.js(v1)</li>
<li>只有三个区中的文件集合都一致的时候，<code>git status</code>才会显示为空</li>
</ul>
<h4 id="2-_git_reset__u4E09_u6B65_u539F_u7406"><a href="#2-_git_reset__u4E09_u6B65_u539F_u7406" class="headerlink" title="2. git reset 三步原理"></a>2. <code>git reset</code> 三步原理</h4><ol>
<li>dfd</li>
<li>dsf</li>
</ol>
<h2 id="Git_u5206_u652F"><a href="#Git_u5206_u652F" class="headerlink" title="Git分支"></a>Git分支</h2><h4 id="1-__u5206_u652F_u7B80_u4ECB"><a href="#1-__u5206_u652F_u7B80_u4ECB" class="headerlink" title="1. 分支简介"></a>1. 分支简介</h4><ul>
<li>Git的分支，其实本质上仅仅是指向commit对象的可变指针</li>
<li>git创建分支，其实是为你创建了一个可以移动的新的指针</li>
<li>通过<code>HEAD</code>这个特殊指针，GIT获知当前在哪个分支上。<code>HEAD</code>可被看作为当前分支的别名。可以简单认为<code>checkout</code>到哪儿，<code>HEAD</code>移动到哪儿</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev&#10;  HEAD -&#62; master&#10;             &#8595;&#10;98ca9 &#60;--- f30ab&#10;             &#8593;&#10;            dev&#10;&#10;$ git checkout -b dev // &#24403;&#26032;&#24314;&#24182;&#20999;&#25442;&#21040;dev&#20998;&#25903;&#26102;&#65292;HEAD&#25165;&#20250;&#31227;&#21160;&#10;           master&#10;             &#8595;&#10;98ca9 &#60;--- f30ab&#10;             &#8593;&#10;            dev &#60;- HEAD</span><br></pre></td></tr></table></figure>
<ul>
<li>如果分别在master和dev上进行commit，则历史记录就会开始分叉</li>
<li>由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就像是往一个文件中写入 41 个字节（40 个字符和 1 个换行符）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="git_config"><a href="#git_config" class="headerlink" title="git config"></a>git config</h2><h4 id="1-config_file__u6709_u4EE5_u4E0B_]]>
    </summary>
    
      <category term="git" scheme="http://zhangfengqi.xyz/tags/git/"/>
    
      <category term="工具" scheme="http://zhangfengqi.xyz/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git 学习总结]]></title>
    <link href="http://zhangfengqi.xyz/2015/11/09/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://zhangfengqi.xyz/2015/11/09/git学习总结/</id>
    <published>2015-11-08T16:00:00.000Z</published>
    <updated>2016-01-11T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>为了在工作中使用git时不捅娄子，这里主要基于廖雪峰老师的git教程所做的学习总结，在实际中遇到的问题也会不断更新进来。<br><a id="more"></a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
<h2 id="u63D0_u4EA4_u5230_u672C_u5730_u7248_u672C_u5E93"><a href="#u63D0_u4EA4_u5230_u672C_u5730_u7248_u672C_u5E93" class="headerlink" title="提交到本地版本库"></a>提交到本地版本库</h2><p><code>git add</code> &amp; <code>git commit</code></p>
<p>git当中的<code>add</code>和<code>commit</code>与svn有所区别原因：分布式vs集中式</p>
<p>由于git的分布式决定了我们每个人的电脑上都是一个完整的版本库(repository)，因此<code>add</code>和<code>commit</code>都是相对于自己本地的版本库而言的。</p>
<p>版本库里存了很多东西，其中最重要的就是：</p>
<ol>
<li>称为stage（或者叫index）的<strong>暂存区</strong>；</li>
<li>还有Git为我们自动创建的<strong>第一个分支</strong>，即主干<code>master</code>，以及指向master的一个指针叫<code>HEAD</code>。</li>
</ol>
<h4 id="u5173_u4E8EHEAD"><a href="#u5173_u4E8EHEAD" class="headerlink" title="关于HEAD"></a>关于<code>HEAD</code></h4><p><code>HEAD</code>意思是当前分支的最新版本，但其实它直接指向的是当前分支。</p>
<p>如果只有一个主分支，即主干<code>master</code>，那<code>HEAD</code>指向的是<code>master</code>，而<code>master</code>再指向于最新版本</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/0013849087937492135fbf4bbd24dfcbc18349a8a59d36d000/0" alt="HEAD与master"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add a.txt // 添加某文件到本地版本库的暂存区</span><br><span class="line">$ git add b.txt</span><br><span class="line">$ git add .     // 添加所有non-version文件到本地库暂存区</span><br><span class="line">$ git commit -m <span class="string">"add 2 files"</span> // 提交暂存区内所有文件到分支(如master)</span><br></pre></td></tr></table></figure>
<p>添加文件到Git仓库，分两步：</p>
<ul>
<li><p>第一步，使用命令<code>git add &lt;file&gt;</code> —— 暂存区</p>
<p>  <strong>注意，可反复多次使用，添加多个文件；</strong></p>
</li>
<li><p>第二步，使用命令<code>git commit</code> 完成。—— 分支</p>
<p>  <strong>注意，commit之后，暂存区就会被清空</strong></p>
</li>
</ul>
<p>ps. 这时只是添加到本地库，而不是远程的版本库github</p>
<h2 id="u8FDC_u7A0B_u5E93_github"><a href="#u8FDC_u7A0B_u5E93_github" class="headerlink" title="远程库 github"></a>远程库 github</h2><h4 id="u5148_u6709_u672C_u5730_u5E93_uFF0C_u540E_u6709_u8FDC_u7A0B_u5E93_u7684_u65F6_u5019_uFF0C_u5982_u4F55_u5173_u8054_u8FDC_u7A0B_u5E93"><a href="#u5148_u6709_u672C_u5730_u5E93_uFF0C_u540E_u6709_u8FDC_u7A0B_u5E93_u7684_u65F6_u5019_uFF0C_u5982_u4F55_u5173_u8054_u8FDC_u7A0B_u5E93" class="headerlink" title="先有本地库，后有远程库的时候，如何关联远程库"></a>先有本地库，后有远程库的时候，如何关联远程库</h4><ol>
<li>github上新建一个repository</li>
<li><code>git remote add origin git@server-name:path/repo-name.git</code></li>
</ol>
<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>
<h4 id="u514B_u9686_u8FDC_u7A0B_u5E93"><a href="#u514B_u9686_u8FDC_u7A0B_u5E93" class="headerlink" title="克隆远程库"></a>克隆远程库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">...</span><br><span class="line">$ git branch</span><br><span class="line">*master</span><br></pre></td></tr></table></figure>
<p>当使用clone命令克隆一个远程库时，默认情况下，只能看到本地的master分支。</p>
<p>如果想要获取dev分支，在上面开发，怎么办？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 必须创建远程origin的dev分支到本地</span><br><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>
<h4 id="u67E5_u770B_u8FDC_u7A0B_u5E93_u4FE1_u606F"><a href="#u67E5_u770B_u8FDC_u7A0B_u5E93_u4FE1_u606F" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line">$ git remote -v // 详细信息</span><br><span class="line">octocat https://github.com/octocat/Spoon-Knife.git (fetch)</span><br><span class="line">octocat https://github.com/octocat/Spoon-Knife.git (push)</span><br><span class="line">origin  https://github.com/zfengqi/Spoon-Knife.git (fetch)</span><br><span class="line">origin  https://github.com/zfengqi/Spoon-Knife.git (push)</span><br><span class="line">// 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</span><br></pre></td></tr></table></figure>
<h4 id="u63A8_u9001_u5206_u652F"><a href="#u63A8_u9001_u5206_u652F" class="headerlink" title="推送分支"></a>推送分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master // 指定本地分支，然后就会推送到对应的分支去</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>
<h4 id="u6293_u53D6_u5206_u652F"><a href="#u6293_u53D6_u5206_u652F" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>因为远程分支版本比你的本地的要新，需要先用<code>git pull</code>试图合并，即update代码</p>
<p>如果<code>git pull</code>合并有冲突，则需要解决冲突，并在本地提交；</p>
<p>如果git pull提示 <strong>no tracking information</strong>，则说明本地分支和远程分支的链接关系没有创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream &lt;branch-name&gt; &lt;origin/branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="u7248_u672C_u56DE_u6EDA"><a href="#u7248_u672C_u56DE_u6EDA" class="headerlink" title="版本回滚"></a>版本回滚</h2><ol>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br><span class="line">$ git reset --hard HEAD^ // 回滚上个版本</span><br><span class="line">$ git reset --hard HEAD^^ // 回滚到上两个版本</span><br><span class="line">$ git reset --hard HEAD~<span class="number">100</span> // 回滚到前<span class="number">100</span>个版本</span><br></pre></td></tr></table></figure>
<ol>
<li>穿梭前，用git log可以查看提交历史，主要找版本号，以便确定要回滚到哪个版本。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit <span class="number">5</span>a396f23af1729fa0c0049c58d42fe0d71541665</span><br><span class="line">Author: kei &lt;zfengqi90@gmail.com&gt;</span><br><span class="line">Date:   Fri Jul <span class="number">10</span> <span class="number">15</span>:<span class="number">20</span>:<span class="number">21</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Update README.md</span><br><span class="line"></span><br><span class="line">commit e325faab05ad640d1e1dc31873dfd362b9c00a92</span><br><span class="line">Author: zhangfengqi &lt;jackyzfq@qq.com&gt;</span><br><span class="line">Date:   Fri Jul <span class="number">10</span> <span class="number">12</span>:<span class="number">50</span>:<span class="number">58</span> <span class="number">2015</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    javascript继承总结</span><br><span class="line"></span><br><span class="line">//如果嫌输出信息太多，看得眼花缭乱的，可以试试</span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">// 退出或者终止<span class="built_in">log</span> 按q</span><br></pre></td></tr></table></figure>
<ol>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line"><span class="number">9</span>a2f804 HEAD@&#123;<span class="number">0</span>&#125;: pull: Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"><span class="number">3</span>bb1509 HEAD@&#123;<span class="number">1</span>&#125;: commit: 函数柯里化总结</span><br><span class="line">e325faa HEAD@&#123;<span class="number">2</span>&#125;: commit: javascript继承总结</span><br><span class="line">bd0213d HEAD@&#123;<span class="number">3</span>&#125;: <span class="built_in">clone</span>: from https://github.com/zfengqi/blog-and-note.git</span><br></pre></td></tr></table></figure>
<h2 id="u6682_u5B58_u533A_u4E0E_u5DE5_u4F5C_u533A_u4E4B_u95F4_u7684_u4FEE_u6539"><a href="#u6682_u5B58_u533A_u4E0E_u5DE5_u4F5C_u533A_u4E4B_u95F4_u7684_u4FEE_u6539" class="headerlink" title="暂存区与工作区之间的修改"></a>暂存区与工作区之间的修改</h2><h4 id="u573A_u666F1_uFF1A_u5F53_u4F60_u6539_u4E71_u4E86_u5DE5_u4F5C_u533A_u67D0_u4E2A_u6587_u4EF6_u7684_u5185_u5BB9_uFF0C_u60F3_u76F4_u63A5_u4E22_u5F03_u5DE5_u4F5C_u533A_u7684_u4FEE_u6539"><a href="#u573A_u666F1_uFF1A_u5F53_u4F60_u6539_u4E71_u4E86_u5DE5_u4F5C_u533A_u67D0_u4E2A_u6587_u4EF6_u7684_u5185_u5BB9_uFF0C_u60F3_u76F4_u63A5_u4E22_u5F03_u5DE5_u4F5C_u533A_u7684_u4FEE_u6539" class="headerlink" title="场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改"></a>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改</h4><p><strong>用命令<code>git checkout -- &lt;file&gt;</code></strong></p>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<ol>
<li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改，本地文件就恢复到暂存区的版本。</li>
</ol>
<p>ps. 修改的是工作区的文件内容，即本地文件。</p>
<h4 id="u573A_u666F2_uFF1A_u5F53_u4F60_u4E0D_u4F46_u6539_u4E71_u4E86_u5DE5_u4F5C_u533A_u67D0_u4E2A_u6587_u4EF6_u7684_u5185_u5BB9_uFF0C_u8FD8_u6DFB_u52A0_u5230_u4E86_u6682_u5B58_u533A_u65F6_uFF0C_u60F3_u4E22_u5F03_u6682_u5B58_u533A_u5173_u4E8E_u8FD9_u4E2A_u6587_u4EF6_u7684_u8BB0_u5F55"><a href="#u573A_u666F2_uFF1A_u5F53_u4F60_u4E0D_u4F46_u6539_u4E71_u4E86_u5DE5_u4F5C_u533A_u67D0_u4E2A_u6587_u4EF6_u7684_u5185_u5BB9_uFF0C_u8FD8_u6DFB_u52A0_u5230_u4E86_u6682_u5B58_u533A_u65F6_uFF0C_u60F3_u4E22_u5F03_u6682_u5B58_u533A_u5173_u4E8E_u8FD9_u4E2A_u6587_u4EF6_u7684_u8BB0_u5F55" class="headerlink" title="场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃暂存区关于这个文件的记录"></a>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃暂存区关于这个文件的记录</h4><p><strong>分两步</strong></p>
<ul>
<li>第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1,即撤销了对这个文件的add操作！</li>
<li>第二步按场景1操作。</li>
</ul>
<h4 id="u573A_u666F3_uFF1A_u5DF2_u7ECF_u63D0_u4EA4_u4E86_u4E0D_u5408_u9002_u7684_u4FEE_u6539_u5230_u7248_u672C_u5E93_u65F6_uFF0C_u60F3_u8981_u64A4_u9500_u672C_u6B21_u63D0_u4EA4_uFF0C_u7248_u672C_u56DE_u6EDA_uFF0C_u4E0D_u8FC7_u524D_u63D0_u662F_u6CA1_u6709_u63A8_u9001_u5230_u8FDC_u7A0B_u5E93_u3002"><a href="#u573A_u666F3_uFF1A_u5DF2_u7ECF_u63D0_u4EA4_u4E86_u4E0D_u5408_u9002_u7684_u4FEE_u6539_u5230_u7248_u672C_u5E93_u65F6_uFF0C_u60F3_u8981_u64A4_u9500_u672C_u6B21_u63D0_u4EA4_uFF0C_u7248_u672C_u56DE_u6EDA_uFF0C_u4E0D_u8FC7_u524D_u63D0_u662F_u6CA1_u6709_u63A8_u9001_u5230_u8FDC_u7A0B_u5E93_u3002" class="headerlink" title="场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回滚，不过前提是没有推送到远程库。"></a>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回滚，不过前提是没有推送到远程库。</h4><h4 id="u6CE8_u610Fgit_checkout_-__26lt_3Bfile_26gt_3B_u7684_u542B_u4E49"><a href="#u6CE8_u610Fgit_checkout_-__26lt_3Bfile_26gt_3B_u7684_u542B_u4E49" class="headerlink" title="注意git checkout -- &lt;file&gt;的含义"></a>注意<code>git checkout -- &lt;file&gt;</code>的含义</h4><p><code>git checkout -- &lt;file&gt;</code>其实是用版本库里的版本（包括暂存区）替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="u521B_u5EFA_u548C_u5408_u5E76_u5206_u652F"><a href="#u521B_u5EFA_u548C_u5408_u5E76_u5206_u652F" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h2><h4 id="git_u5206_u652F_u521B_u5EFA_u539F_u7406"><a href="#git_u5206_u652F_u521B_u5EFA_u539F_u7406" class="headerlink" title="git分支创建原理"></a>git分支创建原理</h4><p>在SVN当中，创建和切换分支的速度是很慢的，而在git里面就是1秒钟的事。</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/001384908811773187a597e2d844eefb11f5cf5d56135ca000/0" alt="创建分支图示"></p>
<ul>
<li><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD改为指向dev，就表示当前分支在dev上</p>
</li>
<li><p><strong>因此快的原因在于：</strong> git除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
</li>
<li><p>这时commit，dev和HEAD就会向前移动，而master则停留在原地。</p>
</li>
</ul>
<h4 id="u521B_u5EFA_u5408_u5E76_u5206_u652F_u547D_u4EE4"><a href="#u521B_u5EFA_u5408_u5E76_u5206_u652F_u547D_u4EE4" class="headerlink" title="创建合并分支命令"></a>创建合并分支命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git branch // 查看已有的分支</span><br><span class="line"></span><br><span class="line">$ git branch new_branch // 创建分支(并没有切换)</span><br><span class="line">$ git checkout new_branch // 切换分支</span><br><span class="line">$ git checkout -b new_branch // 创建+切换到new_branch分支</span><br><span class="line"></span><br><span class="line">$ git branch <span class="operator">-d</span> new_branch // 删除分支</span><br><span class="line">$ git branch -D &lt;name&gt; //如果要丢弃一个没有被合并过的分支，可以强行删除</span><br><span class="line">$ git merge new_branch // 在主干master上进行merge</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p><code>Fast-forward</code> 告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<h4 id="u5207_u6362_u5206_u652F_u65F6_u51FA_u73B0_u7684_u72B6_u51B5"><a href="#u5207_u6362_u5206_u652F_u65F6_u51FA_u73B0_u7684_u72B6_u51B5" class="headerlink" title="切换分支时出现的状况"></a>切换分支时出现的状况</h4><p>当前分支如果有没add和commit的内容的话，是没法切换到其他分支的</p>
<p>如果暂时并不想commit，但是又有需要切换到其他分支的话，怎么办？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash // 把当前工作现场“储藏”起来，等以后回来这个分支再继续工作</span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on dev: <span class="number">6224937</span> add merge</span><br></pre></td></tr></table></figure></p>
<p>当再回到此分支时，发现暂存区是空的！需要把之前stash的内容恢复一下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply // 恢复后，stash内容并不删除，需要用git stash drop来删除</span><br><span class="line">$ git stash pop // 恢复的同时把stash内容也删了</span><br></pre></td></tr></table></figure></p>
<p>stash的另一种使用场景：当当前分支代码没有commit时，是无法pull代码下来，这时需要先stash</p>
<h4 id="u89E3_u51B3_u51B2_u7A81"><a href="#u89E3_u51B3_u51B2_u7A81" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>当在不同的分支，对同一个文件的同一个位置进行了修改，各自commit之后merge时：</p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt="不同分支的提交合并冲突"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zhangfengqi@ED63038F43AD14D /D/zfengqi/github/Spoon-Knife (master)</span><br><span class="line">$ git merge branch222</span><br><span class="line">Auto-merging styles.css</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> styles.css</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>这时候分支状态就会变成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangfengqi@ED63038F43AD14D /D/zfengqi/github/Spoon-Knife (master|MERGING)</span><br></pre></td></tr></table></figure></p>
<p>手动解决冲突：打开发生冲突的文件，保留最终要的部分</p>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容</p>
<p>修改后，再次add &amp; commit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph //可以看到分支合并图。</span><br></pre></td></tr></table></figure>
<h2 id="u5E38_u7528_u547D_u4EE4"><a href="#u5E38_u7528_u547D_u4EE4" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">pwd</span>用于显示当前目录</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/michael/learngit</span><br><span class="line"></span><br><span class="line">//cat</span><br><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>为了在工作中使用git时不捅娄子，这里主要基于廖雪峰老师的git教程所做的学习总结，在实际中遇到的问题也会不断更新进来。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://zhangfengqi.xyz/tags/git/"/>
    
      <category term="工具" scheme="http://zhangfengqi.xyz/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一道面试题]]></title>
    <link href="http://zhangfengqi.xyz/2015/09/25/javascript/%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/problem/"/>
    <id>http://zhangfengqi.xyz/2015/09/25/javascript/一道面试题/problem/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2015-09-24T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="PROBLEM_3A"><a href="#PROBLEM_3A" class="headerlink" title="PROBLEM:"></a>PROBLEM:</h1><h2 id="SALES_TAXES"><a href="#SALES_TAXES" class="headerlink" title="SALES TAXES"></a>SALES TAXES</h2><p>Basic sales tax is applicable at a rate of 10% on all goods, except books,<br>food, and medical products that are exempt. Import duty is an additional<br>sales tax applicable on all imported goods at a rate of 5%, with no<br>exemptions.</p>
<p>When I purchase items I receive a receipt which lists the name of all the<br>items and their price (including tax), finishing with the total cost of the items, and the total amounts of sales taxes paid.<br>The rounding rules for sales tax are that for a tax rate of n%, a shelf price of p contains (np/100 rounded up to the nearest 0.05) amount of sales tax.</p>
<p>Write an application that prints out the receipt details for these<br>shopping baskets…</p>
<p><strong>INPUT:</strong><br>Input 1:<br>1 book at 12.49<br>1 music CD at 14.99<br>1 chocolate bar at 0.85</p>
<p><strong>OUTPUT:</strong><br>Output 1:<br>1 book :12.49<br>1 music CD: 16.49<br>1 chocolate bar: 0.85<br>Sales Taxes: 1.50<br>Total: 29.83</p>
<p><strong>Input 2:</strong><br>1 imported box of chocolates at 10.00<br>1 imported bottle of perfume at 47.50</p>
<p><strong>Output 2:</strong><br>1 imported box of chocolates:10.50<br>1 imported bottle of perfume: 54.65<br>Sales Taxes: 7.65<br>Total: 65.15</p>
<p><strong>Input 3:</strong><br>1 imported bottle of perfume at 27.99<br>1 bottle of perfume at 18.99<br>1 packet of headache pills at 9.75<br>1 box of imported chocolates at 11.25</p>
<p><strong>Output 3:</strong><br>1 imported bottle of perfume: 32.19<br>1 bottle of perfume: 20.89<br>1 packet of headache pills: 9.75<br>1 box of imported chocolates: 11.85<br>Sales Taxes: 6.70<br>Total: 74.68</p>
<blockquote>
<p>浮点数精度问题<br><a href="http://madscript.com/javascript/javscript-float-number-compute-problem/" target="_blank" rel="external">http://madscript.com/javascript/javscript-float-number-compute-problem/</a></p>
</blockquote>
<h1 id="My_answer"><a href="#My_answer" class="headerlink" title="My answer"></a>My answer</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SalesTaxesCalculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tax = &#123;</span><br><span class="line">        basic: <span class="number">0.1</span>,</span><br><span class="line">        <span class="keyword">import</span>: 0.05</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.basicExemptions = &#123;</span><br><span class="line">        book: [<span class="string">'book'</span>],</span><br><span class="line">        food: [<span class="string">'chocolate'</span>],</span><br><span class="line">        med: [<span class="string">'pill'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.totalTaxes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不含税总价格</span></span><br><span class="line">    <span class="keyword">this</span>.totalPrices = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 总入口</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;string&#125; dataChunk 多行数据文本</span><br><span class="line"> * @return &#123;string&#125; 最终计算结果</span><br><span class="line"> */</span></span><br><span class="line">SalesTaxesCalculator.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params">dataChunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清空total</span></span><br><span class="line">    <span class="keyword">this</span>.totalPrices = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.totalTaxes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> itemArr = dataChunk.split(<span class="regexp">/\r\n|\r|\n/g</span>);</span><br><span class="line">    <span class="keyword">var</span> priceWithTaxes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> itemInfo = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> outputText = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">var</span> outputArr = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; itemArr.length; i++) &#123;</span><br><span class="line">        priceWithTaxes = <span class="keyword">this</span>.calculate(itemArr[i]);</span><br><span class="line">        itemInfo = <span class="keyword">this</span>.analyse(itemArr[i]);</span><br><span class="line"></span><br><span class="line">        outputArr.push(itemInfo.count + <span class="string">' '</span> + itemInfo.product + <span class="string">': '</span> + priceWithTaxes.toFixed(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputArr.push(<span class="string">'Sales Taxes: '</span> + <span class="keyword">this</span>.totalTaxes.toFixed(<span class="number">2</span>));</span><br><span class="line">    outputArr.push(<span class="string">'Total: '</span> + (<span class="keyword">this</span>.totalPrices + <span class="keyword">this</span>.totalTaxes).toFixed(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outputArr.join(<span class="string">'\r\n'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 是否为进口商品</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; name 商品相关信息(通过正则匹配)</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span></span><br><span class="line">SalesTaxesCalculator.prototype.isImport = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/import/</span>.test(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  是否为basic tax免税商品</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; name 商品相关信息(正则匹配)</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span></span><br><span class="line">SalesTaxesCalculator.prototype.isExemptions = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exemptions = <span class="keyword">this</span>.basicExemptions;</span><br><span class="line">    <span class="keyword">var</span> reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> exemptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exemptions.hasOwnProperty(key)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; exemptions[key].length; i++) &#123;</span><br><span class="line">                reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(exemptions[key][i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reg.test(name)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取单条记录的商品含税价格</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; data 单行记录</span><br><span class="line"> * @return 含税价格</span><br><span class="line"> */</span></span><br><span class="line">SalesTaxesCalculator.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dataObj = <span class="keyword">this</span>.analyse(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> productInfo = dataObj.product;</span><br><span class="line">    <span class="keyword">var</span> count = dataObj.count;</span><br><span class="line">    <span class="keyword">var</span> price = dataObj.price;</span><br><span class="line">    <span class="keyword">var</span> priceWithoutTaxes = price * count;</span><br><span class="line">    <span class="keyword">var</span> taxRate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> finalTax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isImport(productInfo)) &#123;</span><br><span class="line">        taxRate += <span class="keyword">this</span>.tax[<span class="string">'import'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isExemptions(productInfo)) &#123;</span><br><span class="line">        taxRate += <span class="keyword">this</span>.tax[<span class="string">'basic'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (taxRate !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tax = (taxRate * price).toFixed(<span class="number">3</span>);</span><br><span class="line">        tax = tax.substring(<span class="number">0</span>, tax.length - <span class="number">1</span>);</span><br><span class="line">        finalTax = count * <span class="keyword">this</span>.roundToPercent5(tax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.totalTaxes += finalTax;</span><br><span class="line">    <span class="keyword">this</span>.totalPrices += priceWithoutTaxes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finalTax + priceWithoutTaxes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 向上取0.05的倍数 rounded up to the nearest 0.05</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; tax 未取整的税额</span><br><span class="line"> * @return &#123;number&#125; 取整后税额</span><br><span class="line"> */</span></span><br><span class="line">SalesTaxesCalculator.prototype.roundToPercent5 = <span class="function"><span class="keyword">function</span> (<span class="params">tax</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = tax.replace(<span class="regexp">/\d$/</span>, <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">var</span> end = (+start + <span class="number">0.1</span>).toFixed(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 浮点数精度问题 烦人</span></span><br><span class="line">    <span class="comment">// 取xx.x5</span></span><br><span class="line">    <span class="keyword">var</span> pivot = <span class="built_in">parseInt</span>((+start + +end) / <span class="number">2</span> * <span class="number">100</span>);</span><br><span class="line">    tax = <span class="built_in">parseInt</span>(tax * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> delta = pivot - tax;</span><br><span class="line">    <span class="keyword">if</span> (delta === <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tax / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pivot / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> +end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 分析单行数据</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;string&#125; data 输入源-单行数据文本</span><br><span class="line"> * @return &#123;Object&#125; 解析后的数据对象 &#123;商品数量、商品信息、商品价格&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// data: 1 imported bottle of perfume at 47.50</span></span><br><span class="line">SalesTaxesCalculator.prototype.analyse = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    data = data.trim();</span><br><span class="line">    <span class="keyword">var</span> tempArr = data.split(<span class="regexp">/\sat\s/</span>);</span><br><span class="line">    <span class="keyword">var</span> price = tempArr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempArr2 = tempArr[<span class="number">0</span>].split(<span class="regexp">/\s/</span>);</span><br><span class="line">    <span class="keyword">var</span> count = tempArr2.shift();</span><br><span class="line">    <span class="keyword">var</span> product = tempArr2.join(<span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: +count,</span><br><span class="line">        product: product,</span><br><span class="line">        price: +price</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> INPUT = <span class="string">'1 book at 12.49 \r\n 1 music CD at 14.99 \r\n 1 chocolate bar at 0.85'</span>;</span><br><span class="line"><span class="comment">// var INPUT = '1 imported box of chocolates at 10.00 \r\n 1 imported bottle of perfume at 47.50 ';</span></span><br><span class="line"><span class="comment">// var INPUT = '1 imported bottle of perfume at 27.99 \r\n 1 bottle of perfume at 18.99 \r\n 1 packet of headache pills at 9.75 \r\n 1 box of imported chocolates at 11.25 ';</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cal = <span class="keyword">new</span> SalesTaxesCalculator();</span><br><span class="line"><span class="built_in">console</span>.log(cal.run(INPUT));</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="PROBLEM_3A"><a href="#PROBLEM_3A" class="headerlink" title="PROBLEM:"></a>PROBLEM:</h1><h2 id="SALES_TAXES"><a href="#SALES_TAXES" c]]>
    </summary>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/tags/javascript/"/>
    
      <category term="面试" scheme="http://zhangfengqi.xyz/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <link href="http://zhangfengqi.xyz/2015/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"/>
    <id>http://zhangfengqi.xyz/2015/09/07/计算机网络基础—未完待续/</id>
    <published>2015-09-06T16:00:00.000Z</published>
    <updated>2015-09-06T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>非科班学生尝试恶补计算机网络基础，未完待续《计算机网络简明教程》<br><a id="more"></a></p>
<blockquote>
<p><strong>from 《计算机网络简明教程》 —— 谢希仁</strong></p>
</blockquote>
<h2 id="ISP__28Internet_Service_Provider_29"><a href="#ISP__28Internet_Service_Provider_29" class="headerlink" title="ISP (Internet Service Provider)"></a>ISP (Internet Service Provider)</h2><ol>
<li>可从英特网管理机构申请到成块的IP地址</li>
<li>同时拥有通信线路（大的ISP自己造，小的租）</li>
<li>“上网”指的是通过某个ISP接入到因特网。</li>
<li>IP地址管理机构不零售单个IP地址给个人用户，而是批发给ISP,由ISP再进行零售</li>
<li><strong>NAP网络接入点</strong>：为了使不同层次ISP经营的网络能够互通</li>
<li>相隔较远的两台主机的通信可能需要经过多个ISP</li>
</ol>
<table>
<thead>
<tr>
<th>ISP级别</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一层ISP</td>
<td>最高级别，一般覆盖国家</td>
<td>拥有高速主干网</td>
</tr>
<tr>
<td>第二层ISP</td>
<td>包括一些大公司</td>
<td>都是第一层ISP的用户</td>
</tr>
<tr>
<td>本地ISP（第三层）</td>
<td>包括校园网、企业网和拨号上网的用户</td>
<td>只拥有本地网络，是第二层ISP的用户</td>
</tr>
</tbody>
</table>
<h2 id="u56E0_u7279_u7F51_u7684_u7EC4_u6210"><a href="#u56E0_u7279_u7F51_u7684_u7EC4_u6210" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ol>
<li>边缘部分<ul>
<li>连接在因特网上的所有主机（又称端系统），这些主机可以是pad、大型计算机，也可以是ISP</li>
<li>边缘部分利用核心部分所提供的服务，使主机之间能够互相通信。</li>
<li>端系统的通信方式： 客户端-服务器方式（C/S，注B/S是其一种特例）和对等方式（P2P）</li>
</ul>
</li>
<li>核心部分<ul>
<li>向网络边缘提供连通性，核心主干是路由器</li>
<li>路由器是实现分组（包）交换的关键构件，其任务是转发收到的分组。</li>
<li>路由器不属于主机，主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。</li>
<li>分组交换采用 <strong>存储转发</strong> 技术，要发送的整块数据成为一个 <strong>报文</strong>，发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，在每个数据段前面，加上一些由必要的控制信息组成的 <strong>首部</strong> 后，构成一个 <strong>分组</strong>，也成为 <strong>包(packet)</strong></li>
<li>分组交换与电路交换相比的优点</li>
</ul>
</li>
</ol>
<h2 id="u4EC0_u4E48_u662F_u5E26_u5BBD"><a href="#u4EC0_u4E48_u662F_u5E26_u5BBD" class="headerlink" title="什么是带宽"></a>什么是带宽</h2><ul>
<li>用来表示网络的通信线路所能传送数据的能力</li>
<li>单位时间内从网络的某一点到另一点所能通过的 <strong>“最高数据率”</strong></li>
<li>单位为 b/s … Gb/s</li>
</ul>
<h2 id="u4E94_u5C42_u534F_u8BAE_u4F53_u7CFB_u7ED3_u6784"><a href="#u4E94_u5C42_u534F_u8BAE_u4F53_u7CFB_u7ED3_u6784" class="headerlink" title="五层协议体系结构"></a>五层协议体系结构</h2><h3 id="1-__u5E94_u7528_u5C42"><a href="#1-__u5E94_u7528_u5C42" class="headerlink" title="1. 应用层"></a>1. 应用层</h3><ul>
<li>直接为用户的应用进程（即正在运行的软件程序）提供服务。</li>
<li>包括HTTP SMTP FTP…</li>
</ul>
<h3 id="2-__u4F20_u8F93_u5C42"><a href="#2-__u4F20_u8F93_u5C42" class="headerlink" title="2. 传输层"></a>2. 传输层</h3><ul>
<li>负责向两台主机中的进程之间（端对端）的提供可靠报文传输和错误恢复。</li>
<li>复用：多个应用层进程可同时使用下面传输层的服务；</li>
<li>分用：传输层把收到的信息分别交付给上面应用层中相应的进程。</li>
<li><strong>TCP：</strong>面向连接，数据传输的单位是<strong>报文段(segment)</strong></li>
<li><strong>UDP：</strong>无连接，传输单位为<strong>用户数据报</strong>，尽最大努力交付</li>
</ul>
<h3 id="3-__u7F51_u7EDC_u5C42_28_u4E5F_u79F0_u7F51_u9645_u5C42_IP_u5C42_29"><a href="#3-__u7F51_u7EDC_u5C42_28_u4E5F_u79F0_u7F51_u9645_u5C42_IP_u5C42_29" class="headerlink" title="3. 网络层(也称网际层 IP层)"></a>3. 网络层(也称网际层 IP层)</h3><ul>
<li>负责为不同的主机之间提供通信服务，注意只精确到主机之间而非指定进程</li>
<li>把传输层产生的报文段或用户数据报封装成分组或包进行传输。也称为IP数据报</li>
<li>另一个任务是：使主机传输层所传下来的包，能够通过网络中的路由器找到合适的路由，最后到达目的主机。即寻路。</li>
</ul>
<h4 id="u7F51_u7EDC_u5C42_u4E0D_u4FDD_u8BC1_u670D_u52A1_u8D28_u91CF"><a href="#u7F51_u7EDC_u5C42_u4E0D_u4FDD_u8BC1_u670D_u52A1_u8D28_u91CF" class="headerlink" title="网络层不保证服务质量"></a>网络层不保证服务质量</h4><ul>
<li>向上只提供简单灵活、无连接的、尽最大努力交付的数据报服务</li>
<li>当主机中的进程之间的通信需要是可靠的时，就由主机中的传输层负责提供可靠传输</li>
</ul>
<h4 id="IP_u5730_u5740_28IPv4_29"><a href="#IP_u5730_u5740_28IPv4_29" class="headerlink" title="IP地址(IPv4)"></a>IP地址(IPv4)</h4><p>最初使用分类的IP地址，先已普遍采用无分类编址方法</p>
<p><strong>分类地址：</strong> 网络号 + 主机号 共32位</p>
<table>
<thead>
<tr>
<th>地址类别</th>
<th>网络号字段</th>
<th>主机号字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>A类地址</td>
<td>0 + 网络号（共8位 1字节）</td>
<td>主机号(共24位)</td>
</tr>
<tr>
<td>B类地址</td>
<td>10 + 网络号（共16位 2字节）</td>
<td>主机号(共16位)</td>
</tr>
<tr>
<td>C类地址</td>
<td>110 + 网络号（共24位 3字节）</td>
<td>主机号(共8位)</td>
</tr>
<tr>
<td>D类地址</td>
<td>1110</td>
<td>多播地址</td>
</tr>
<tr>
<td>E类地址</td>
<td>1111</td>
<td>保留位今后使用</td>
</tr>
</tbody>
</table>
<p><strong>点分十进制记法：</strong> 如128.11.3.31</p>
<ol>
<li>每8位用其等效的十进制数表示，并在这些数之间加一个点。</li>
<li>第一个十进制数：0~127是A类； 128~191是B类；192~223C类； 224~239D类； 240~255E类</li>
</ol>
<p><strong>IP地址与MAC地址</strong></p>
<ul>
<li>IP地址：并不仅仅指明一台主机，还指明了主机所连接到的网络。</li>
<li>MAC地址：仅仅指明一台主机，与该主机所连接的网络毫无关系。</li>
</ul>
<h4 id="ARP_u662F_u5730_u5740_u89E3_u6790_u534F_u8BAE_uFF0C_u7B80_u5355_u8BED_u8A00_u89E3_u91CA_u4E00_u4E0B_u5DE5_u4F5C_u539F_u7406_u3002"><a href="#ARP_u662F_u5730_u5740_u89E3_u6790_u534F_u8BAE_uFF0C_u7B80_u5355_u8BED_u8A00_u89E3_u91CA_u4E00_u4E0B_u5DE5_u4F5C_u539F_u7406_u3002" class="headerlink" title="ARP是地址解析协议，简单语言解释一下工作原理。"></a>ARP是地址解析协议，简单语言解释一下工作原理。</h4><ol>
<li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</li>
<li>当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。</li>
<li>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</li>
<li>源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</li>
</ol>
<p>广播发送ARP请求，单播发送ARP响应。</p>
<h4 id="IP_u5C42_u8F6C_u53D1_u5206_u7EC4_u7684_u6D41_u7A0B"><a href="#IP_u5C42_u8F6C_u53D1_u5206_u7EC4_u7684_u6D41_u7A0B" class="headerlink" title="IP层转发分组的流程"></a>IP层转发分组的流程</h4><h4 id="u865A_u62DF_u4E13_u7528_u7F51_VPN"><a href="#u865A_u62DF_u4E13_u7528_u7F51_VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h4><p><strong>背景</strong></p>
<ol>
<li>IP地址紧缺，公司或机构所申请到的IP地址数远小于所拥有的主机数；</li>
<li>一个机构内并不需要把所有主机都接入到外部因特网，很多主机只需要和公司内部其他主机通信</li>
<li>因此可以让这些主机使用仅在公司内部有效的IP地址（本地地址），而不需要全球地址。</li>
</ol>
<p>RFC1918指明了一些<strong>专用地址(可重用地址)</strong>：这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。<br><strong>在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>，避免自行分配的本地地址和全球地址相冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0 ~ 10.255.255.255&#10;172.16.0.0 ~ 172.31.255.255&#10;192.168.0.0 ~ 192.168.255.255</span><br></pre></td></tr></table></figure>
<p>分布在不同地点的专用网若需要进行通信，可使用IP隧道技术实现(P112)</p>
<h3 id="4-__u6570_u636E_u94FE_u8DEF_u5C42"><a href="#4-__u6570_u636E_u94FE_u8DEF_u5C42" class="headerlink" title="4. 数据链路层"></a>4. 数据链路层</h3><ul>
<li>将网络层交下来的IP数据报组装成 <strong>帧(frame)</strong>(添加首部和尾部)，在两个相邻节点间的链路上“透明”地传送帧中的数据。</li>
<li><strong>每一帧</strong> 包括数据和必要的控制信息（如同步信息、地址信息、差错控制等），典型帧长为几百到一千多字节</li>
<li>控制信息使接收端能够知道一个帧从哪个bit开始和到哪个bit结束。这样链路层在收到一个帧后，就可以从中提取出数据部分，上交给网络层。A</li>
<li>控制信息还使接收端能够检测到所收到的帧中有无错误，并且可以纠正。</li>
</ul>
<hr>
<h4 id="u94FE_u8DEF_u548C_u6570_u636E_u94FE_u8DEF_u5E76_u4E0D_u662F_u4E00_u56DE_u4E8B"><a href="#u94FE_u8DEF_u548C_u6570_u636E_u94FE_u8DEF_u5E76_u4E0D_u662F_u4E00_u56DE_u4E8B" class="headerlink" title="链路和数据链路并不是一回事"></a>链路和数据链路并不是一回事</h4><p><strong>链路：</strong> 从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</p>
<p><strong>数据链路：</strong> 链路 + 实现必要通信协议的硬件和软件（用来控制数据的传输），一般使用网络适配器来实现这些协议的硬件和软件。</p>
<p><strong>网络适配器（简称网卡）：</strong> 拨号上网 —— 拨号适配器； 以太网上网 —— 局域网适配器</p>
<h4 id="u900F_u660E_u4F20_u8F93"><a href="#u900F_u660E_u4F20_u8F93" class="headerlink" title="透明传输"></a>透明传输</h4><p>如果数据链路层协议允许所传送的数据可具有任意形式的比特组合（即使出现了和帧首部或帧尾部标记完全一样的比特组合，协议也会采取适当的措施来处理）。<br>这样的传输称为透明传输。</p>
<h3 id="5-__u7269_u7406_u5C42"><a href="#5-__u7269_u7406_u5C42" class="headerlink" title="5. 物理层"></a>5. 物理层</h3><ul>
<li>任务是传送比特流</li>
<li>需要考虑的是用多大电压代表1或0，以及接收方如何识别出发送方所发送的bit</li>
<li><strong>注意：</strong> 传递信息所利用的物理媒介，如光缆、电缆、无线信道等，并不包含在物理层协议当中，而是在物理层协议的下面。所以也可以将物理媒介当做第0层。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>非科班学生尝试恶补计算机网络基础，未完待续《计算机网络简明教程》<br>]]>
    
    </summary>
    
      <category term="计算机网络" scheme="http://zhangfengqi.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="基础" scheme="http://zhangfengqi.xyz/categories/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <link href="http://zhangfengqi.xyz/2015/09/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>http://zhangfengqi.xyz/2015/09/05/数据库基础/</id>
    <published>2015-09-04T16:00:00.000Z</published>
    <updated>2015-09-04T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>同是基础恶补系列，阅读<a href="http://book.douban.com/subject/4829597/" target="_blank" rel="external">《漫画数据库》</a>做的笔记，书很薄，以漫画故事的形式讲述，对数据库有个大体的了解<br><a id="more"></a></p>
<h2 id="u4E00-__u4EC0_u4E48_u662F_u6570_u636E_u5E93"><a href="#u4E00-__u4EC0_u4E48_u662F_u6570_u636E_u5E93" class="headerlink" title="一. 什么是数据库"></a>一. 什么是数据库</h2><h3 id="281_29__u6570_u636E_u6A21_u578B_u7684_u79CD_u7C7B"><a href="#281_29__u6570_u636E_u6A21_u578B_u7684_u79CD_u7C7B" class="headerlink" title="(1) 数据模型的种类"></a>(1) 数据模型的种类</h3><ul>
<li>层次数据模型: 每个子数据只能有一个母数据</li>
<li>网状数据模型：可以有多个母数据</li>
</ul>
<p>以上两种都是通过指针连接数据表示他们的关系；难以灵活高效地检索数据</p>
<ul>
<li>关系数据模型 —— 当今主流数据库模型</li>
</ul>
<h3 id="282_29__u5173_u7CFB_u6570_u636E_u6A21_u578B_u2014_u2014_u4F7F_u7528_u8868_u683C"><a href="#282_29__u5173_u7CFB_u6570_u636E_u6A21_u578B_u2014_u2014_u4F7F_u7528_u8868_u683C" class="headerlink" title="(2) 关系数据模型——使用表格"></a>(2) 关系数据模型——使用表格</h3><ol>
<li>以二元表格(table)为基础</li>
<li>在关系数据模型中，称表格为关系(relation)</li>
<li>主键(primary key): 能够唯一确定数据的列</li>
</ol>
<h3 id="283_29__u5173_u7CFB_u6570_u636E_u5E93_u7684_u8FD0_u7B97_u64CD_u4F5C__u2014_u2014__u62BD_u53D6_u6570_u636E_u7684_u65B9_u5F0F"><a href="#283_29__u5173_u7CFB_u6570_u636E_u5E93_u7684_u8FD0_u7B97_u64CD_u4F5C__u2014_u2014__u62BD_u53D6_u6570_u636E_u7684_u65B9_u5F0F" class="headerlink" title="(3) 关系数据库的运算操作 —— 抽取数据的方式"></a>(3) 关系数据库的运算操作 —— 抽取数据的方式</h3><p>1~4为集合运算，5~8为关系运算</p>
<h4 id="1-__u5E76_28union_29"><a href="#1-__u5E76_28union_29" class="headerlink" title="1. 并(union)"></a>1. 并(union)</h4><p>抽取两张表中所有行的运算</p>
<h4 id="2-__u5DEE_28difference_29"><a href="#2-__u5DEE_28difference_29" class="headerlink" title="2. 差(difference)"></a>2. 差(difference)</h4><p>抽取两张表的其中一张表独有行的运算，以不同的表为基准会获得不同的运算结果</p>
<h4 id="3-__u4EA4_28intersection_29"><a href="#3-__u4EA4_28intersection_29" class="headerlink" title="3. 交(intersection)"></a>3. 交(intersection)</h4><p>抽取两张表中都存在的行(记录)</p>
<h4 id="4-__u7B1B_u5361_u5C14_u79EF_28Cartesian_product_29"><a href="#4-__u7B1B_u5361_u5C14_u79EF_28Cartesian_product_29" class="headerlink" title="4. 笛卡尔积(Cartesian product)"></a>4. 笛卡尔积(Cartesian product)</h4><p>将两张表中的所有行进行排列组合</p>
<p>表一 &amp; 表二</p>
<table>
<thead>
<tr>
<th>商品编码</th>
<th>商品名称</th>
<th>单价</th>
<th>←表一 &amp; 表二→</th>
<th>出口国编号</th>
<th>出口国名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>香瓜</td>
<td>800G</td>
<td></td>
<td>12</td>
<td>美国</td>
</tr>
<tr>
<td>102</td>
<td>草莓</td>
<td>123G</td>
<td></td>
<td>23</td>
<td>阿富汗</td>
</tr>
<tr>
<td>103</td>
<td>苹果</td>
<td>545G</td>
<td></td>
<td>25</td>
<td>巴基斯坦</td>
</tr>
</tbody>
</table>
<p>笛卡尔积后，表一的每一行记录会与表二的每一行记录进行组合，形成3*3=9行的新表</p>
<h4 id="5-__u6295_u5F71_28projection_29"><a href="#5-__u6295_u5F71_28projection_29" class="headerlink" title="5. 投影(projection)"></a>5. 投影(projection)</h4><p>抽取一张表中的某一列，如抽取上表一种的商品名称列</p>
<h4 id="6-__u9009_u62E9_28selection_29"><a href="#6-__u9009_u62E9_28selection_29" class="headerlink" title="6. 选择(selection)"></a>6. 选择(selection)</h4><p>抽取表中的某一行</p>
<h4 id="7-__u8FDE_u63A5_28join_29"><a href="#7-__u8FDE_u63A5_28join_29" class="headerlink" title="7. 连接(join)"></a>7. 连接(join)</h4><p>商品表 &amp; 销售表</p>
<table>
<thead>
<tr>
<th>商品编码</th>
<th>商品名称</th>
<th>单价</th>
<th>←商品表 &amp; 销售表→</th>
<th>日期</th>
<th>商品编码</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>香瓜</td>
<td>800G</td>
<td></td>
<td>11/1</td>
<td>102</td>
<td>1100</td>
</tr>
<tr>
<td>102</td>
<td>草莓</td>
<td>150G</td>
<td></td>
<td>11/1</td>
<td>101</td>
<td>300</td>
</tr>
<tr>
<td>103</td>
<td>苹果</td>
<td>120G</td>
<td></td>
<td>11/5</td>
<td>103</td>
<td>1700</td>
</tr>
<tr>
<td>104</td>
<td>柠檬</td>
<td>120G</td>
<td></td>
<td>11/8</td>
<td>101</td>
<td>500</td>
</tr>
</tbody>
</table>
<p>两张表都有共同的字段 <strong>商品编码</strong>，但销售表并没有 <strong>商品名称</strong> 字段</p>
<p><em>销售表</em> 可以通过参考 <em>商品表</em> 中作为主键的 <strong>商品编码</strong> 来找到每条记录所对应的商品名称。</p>
<p>此时，销售表中的商品编码字段就叫做 <strong>外键(foreign key)</strong></p>
<p>外键参照其他表的主键时，通过连接，可以将两张表粘合成如下新表</p>
<table>
<thead>
<tr>
<th>日期</th>
<th>商品编码</th>
<th>商品名称</th>
<th>单价</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>11/1</td>
<td>102</td>
<td>草莓</td>
<td>150G</td>
<td>1100</td>
</tr>
<tr>
<td>11/1</td>
<td>101</td>
<td>香瓜</td>
<td>800G</td>
<td>300</td>
</tr>
<tr>
<td>11/5</td>
<td>103</td>
<td>苹果</td>
<td>120G</td>
<td>1700</td>
</tr>
<tr>
<td>11/8</td>
<td>101</td>
<td>香瓜</td>
<td>800G</td>
<td>500</td>
</tr>
</tbody>
</table>
<h4 id="8-__u9664_28division_29"><a href="#8-__u9664_28division_29" class="headerlink" title="8. 除(division)"></a>8. 除(division)</h4><ol>
<li>从“被除表格”当中抽取“除表格”中的所有行</li>
<li>然后再从中去掉“除表格”中所包含的字段</li>
<li>最后剩下的就是除运算后的结果</li>
</ol>
<h2 id="u4E8C_u3001_u8BBE_u8BA1_u6570_u636E_u5E93"><a href="#u4E8C_u3001_u8BBE_u8BA1_u6570_u636E_u5E93" class="headerlink" title="二、设计数据库"></a>二、设计数据库</h2><h3 id="E-R_u6A21_u578B_u5206_u6790"><a href="#E-R_u6A21_u578B_u5206_u6790" class="headerlink" title="E-R模型分析"></a>E-R模型分析</h3><h3 id="u89C4_u8303_u5316"><a href="#u89C4_u8303_u5316" class="headerlink" title="规范化"></a>规范化</h3><p>第一范式：分割非范式的表格，得到第一范式表格？？</p>
<p>第二范式：主键的值（有可能两个字段组合起来作为主键）可以用来确定其他列的值，用这个原则来分割表格</p>
<p>第三范式</p>
<h2 id="u4E09_u3001SQL_u57FA_u672C_u64CD_u4F5C"><a href="#u4E09_u3001SQL_u57FA_u672C_u64CD_u4F5C" class="headerlink" title="三、SQL基本操作"></a>三、SQL基本操作</h2><h3 id="1-_SELECT"><a href="#1-_SELECT" class="headerlink" title="1. SELECT"></a>1. <code>SELECT</code></h3><p>紧跟着SELECT的是某个字段<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> // *代表所有字段</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`country`</span> <span class="keyword">FROM</span> <span class="string">`table1`</span> // 把表<span class="number">1</span>中country字段的所有记录调取出来</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(单价) <span class="keyword">FROM</span> <span class="string">`table1`</span> // 使用计算函数作为一个字段，注意“单价”不用加引号！</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5E38_u89C1_u7684_u8BA1_u7B97_u51FD_u6570"><a href="#u5E38_u89C1_u7684_u8BA1_u7B97_u51FD_u6570" class="headerlink" title="常见的计算函数"></a><strong>常见的计算函数</strong></h4><table>
<thead>
<tr>
<th>计算函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT(<strong>*</strong>)</td>
<td>求行数</td>
</tr>
<tr>
<td>COUNT(字段名)</td>
<td>求非空值行数</td>
</tr>
<tr>
<td>COUNT(DISTINCT 字段名)</td>
<td>求排除空值和重复行的行数</td>
</tr>
<tr>
<td>SUM(字段名)</td>
<td>求各行的和 (若内容不为num，则结果为0)</td>
</tr>
<tr>
<td>AVG(字段名)</td>
<td>平均值</td>
</tr>
<tr>
<td>MAX(字段名)</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN(字段名)</td>
<td>最小值</td>
</tr>
</tbody>
</table>
<h4 id="WHERE__u6CE8_u610F_u6761_u4EF6_u4E3A_u6570_u5B57_u548C_u5B57_u7B26_u4E32_u65F6_u7684_u5904_u7406"><a href="#WHERE__u6CE8_u610F_u6761_u4EF6_u4E3A_u6570_u5B57_u548C_u5B57_u7B26_u4E32_u65F6_u7684_u5904_u7406" class="headerlink" title="WHERE  注意条件为数字和字符串时的处理"></a><code>WHERE</code>  注意条件为数字和字符串时的处理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`name`</span> = <span class="string">'苹果'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`price`</span> &lt; <span class="number">200</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`price`</span> &lt; &gt; <span class="number">200</span>    // 价格不等于<span class="number">200</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="string">`price`</span> = <span class="number">200</span>  // 同上</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`price`</span> <span class="keyword">BETWEEN</span> <span class="number">150</span> <span class="keyword">AND</span> <span class="number">200</span> // 设范围</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`price`</span> <span class="keyword">IS</span> <span class="literal">NULL</span> // 检索空值</span></span><br></pre></td></tr></table></figure>
<h4 id="LIKE__25__u8868_u793A_u4EFB_u610F_u591A_u4E2A_u5B57_u7B26_uFF1B____u8868_u793A_u5355_u4E2A_u5B57_u7B26"><a href="#LIKE__25__u8868_u793A_u4EFB_u610F_u591A_u4E2A_u5B57_u7B26_uFF1B____u8868_u793A_u5355_u4E2A_u5B57_u7B26" class="headerlink" title="LIKE % 表示任意多个字符； _ 表示单个字符"></a><code>LIKE</code> <strong>%</strong> 表示任意多个字符； <strong>_</strong> 表示单个字符</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">'_果'</span></span><br><span class="line"><span class="keyword">OR</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">'猕%'</span></span></span><br></pre></td></tr></table></figure>
<h4 id="ORDER_BY__u8C03_u53D6_u51FA_u6765_u7684_u7ED3_u679C_u6309_u5347_u5E8F_u6392_u5217"><a href="#ORDER_BY__u8C03_u53D6_u51FA_u6765_u7684_u7ED3_u679C_u6309_u5347_u5E8F_u6392_u5217" class="headerlink" title="ORDER BY 调取出来的结果按升序排列"></a><code>ORDER BY</code> 调取出来的结果按升序排列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">WHERE</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">'%果'</span> <span class="keyword">OR</span> <span class="string">`name`</span> <span class="keyword">LIKE</span> <span class="string">'%莓'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`price`</span></span></span><br></pre></td></tr></table></figure>
<h4 id="GROUP_BY"><a href="#GROUP_BY" class="headerlink" title="GROUP BY"></a><code>GROUP BY</code></h4><p>将数据分组化，可以求出每一组的统计值</p>
<p><code>HAVING</code> 对分组后求得的统计值进行进一步条件设定(注意不是使用<code>WHERE</code>)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 可以求出每个地域的平均单价，如南部 北部 中部</span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">`地域`</span>, <span class="keyword">AVG</span>(单价) <span class="keyword">FROM</span> <span class="string">`table1`</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`地域`</span></span><br><span class="line"></span><br><span class="line">// 若不加<span class="keyword">GROUP</span> <span class="keyword">BY</span> 则只会出现一条记录，均价是所有地域的均价</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`地域`</span>, <span class="keyword">AVG</span>(单价) <span class="keyword">FROM</span> <span class="string">`table1`</span></span><br><span class="line"></span><br><span class="line">// 只抽取出平均单价在<span class="number">200</span>以上的地域</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`地域`</span>, <span class="keyword">AVG</span>(单价) <span class="keyword">FROM</span> <span class="string">`table1`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="string">`地域`</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(单价) &gt;= <span class="number">200</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5B50_u67E5_u8BE2"><a href="#u5B50_u67E5_u8BE2" class="headerlink" title="子查询"></a>子查询</h4><p>例子：检索销售数量在1000以上的商品的名称<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`商品表`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`商品编码`</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="string">`商品编码`</span> <span class="keyword">FROM</span> <span class="string">`销售明细表`</span> <span class="keyword">WHERE</span> <span class="string">`数量`</span> &gt; <span class="number">1000</span>)</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u76F8_u5173_u5B50_u67E5_u8BE2"><a href="#u76F8_u5173_u5B50_u67E5_u8BE2" class="headerlink" title="相关子查询"></a>相关子查询</h4><h3 id="2-_INSERT_INTO"><a href="#2-_INSERT_INTO" class="headerlink" title="2. INSERT INTO"></a>2. <code>INSERT INTO</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`商品表`</span> (商品编码, 商品名称, 单价)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">202</span>， <span class="string">'枇杷'</span>, <span class="number">900</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-_UPDATE"><a href="#3-_UPDATE" class="headerlink" title="3. UPDATE"></a>3. <code>UPDATE</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> <span class="string">`商品表`</span></span><br><span class="line"><span class="keyword">SET</span> <span class="string">`商品名称`</span> = <span class="string">'甜瓜'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`商品名称`</span> = <span class="string">'西瓜'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-_DELETE_FROM"><a href="#4-_DELETE_FROM" class="headerlink" title="4. DELETE FROM"></a>4. <code>DELETE FROM</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="string">`商品表`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`商品名称`</span> = <span class="string">'苹果'</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-_CREATE_TABLE"><a href="#5-_CREATE_TABLE" class="headerlink" title="5. CREATE TABLE"></a>5. <code>CREATE TABLE</code></h3><h2 id="u56DB_u3001_u6570_u636E_u5E93_u5E94_u7528"><a href="#u56DB_u3001_u6570_u636E_u5E93_u5E94_u7528" class="headerlink" title="四、数据库应用"></a>四、数据库应用</h2><h3 id="1-__u4E8B_u52A1_28transaction_29"><a href="#1-__u4E8B_u52A1_28transaction_29" class="headerlink" title="1. 事务(transaction)"></a>1. 事务(transaction)</h3><p>用户的一个连贯操作被称之为数据库事务。</p>
<h4 id="u6570_u636E_u5E93_u4E8B_u52A1ACID_u5C5E_u6027"><a href="#u6570_u636E_u5E93_u4E8B_u52A1ACID_u5C5E_u6027" class="headerlink" title="数据库事务ACID属性"></a>数据库事务ACID属性</h4><table>
<thead>
<tr>
<th>性质</th>
<th>内容</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>A(Atomicity)</td>
<td>原子性</td>
<td>数据库事务必须结束于 <strong>提交(commit)或回滚(rollback)</strong> 中的任意一个任务</td>
</tr>
<tr>
<td>C(Consistency)</td>
<td>一致性</td>
<td>使数据不发生矛盾，事务执行前数据库不存在矛盾，执行后也不能出现矛盾</td>
</tr>
<tr>
<td>I(Isolation)</td>
<td>隔离性</td>
<td>两个事务的执行时互不干扰，一个事务不可能看到其他事务运行时，中间某一时刻的数据</td>
</tr>
<tr>
<td>D(Durability)</td>
<td>持久性</td>
<td>在事务完成后，该事务对数据库所做的更改便持久的保存在数据库中，并不会被回滚</td>
</tr>
</tbody>
</table>
<h4 id="u53EF_u5E8F_u5217_u5316"><a href="#u53EF_u5E8F_u5217_u5316" class="headerlink" title="可序列化"></a>可序列化</h4><p>即便是多个事务并行处理也和逐个处理得到的结果一样时，逐个安排称之为可序列化。</p>
<p>并行执行控制：</p>
<ul>
<li>读取数据-共享锁(其他用户只能读取，不能写入)；</li>
<li>写入数据-独占锁(其他用户读取写入都不允许)</li>
</ul>
<h3 id="2-__u64CD_u4F5C_u6743_u9650_u7684_u8D4B_u4E88_u4E0E_u6536_u56DE"><a href="#2-__u64CD_u4F5C_u6743_u9650_u7684_u8D4B_u4E88_u4E0E_u6536_u56DE" class="headerlink" title="2. 操作权限的赋予与收回"></a>2. 操作权限的赋予与收回</h3><h4 id="GRANT__26amp_3B_REVOKE"><a href="#GRANT__26amp_3B_REVOKE" class="headerlink" title="GRANT &amp; REVOKE"></a><code>GRANT</code> &amp; <code>REVOKE</code></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户</span><br><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户 // 所有权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户X // 收回权限</span><br><span class="line"></span><br><span class="line">// 能够赋予其他用户权限</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span> <span class="keyword">ON</span> 表名 <span class="keyword">TO</span> 用户 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-__u4F7F_u7528_u7D22_u5F15_u8FDB_u884C_u5FEB_u901F_u68C0_u7D22"><a href="#3-__u4F7F_u7528_u7D22_u5F15_u8FDB_u884C_u5FEB_u901F_u68C0_u7D22" class="headerlink" title="3. 使用索引进行快速检索"></a>3. 使用索引进行快速检索</h3><p>在从大量的数据中选择其中一部分数据的情况下，使用索引可以进行快速检索</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>同是基础恶补系列，阅读<a href="http://book.douban.com/subject/4829597/">《漫画数据库》</a>做的笔记，书很薄，以漫画故事的形式讲述，对数据库有个大体的了解<br>]]>
    
    </summary>
    
      <category term="数据库" scheme="http://zhangfengqi.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="基础" scheme="http://zhangfengqi.xyz/categories/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js继承]]></title>
    <link href="http://zhangfengqi.xyz/2015/07/12/javascript/%E7%BB%A7%E6%89%BF/"/>
    <id>http://zhangfengqi.xyz/2015/07/12/javascript/继承/</id>
    <published>2015-07-11T16:00:00.000Z</published>
    <updated>2015-07-11T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>在《javascript模式》一书中，把继承分为了<strong>类式继承</strong>和<strong>原型继承</strong>，以下是对这部分的一个总结。<br><a id="more"></a></p>
<h2 id="u7C7B_u5F0F_u7EE7_u627F"><a href="#u7C7B_u5F0F_u7EE7_u627F" class="headerlink" title="类式继承"></a>类式继承</h2><h3 id="1-_u6700_u5E38_u7528_u7684_u7EE7_u627F_u7EC4_u5408_u6A21_u5F0F__u2014_u2014__u501F_u7528_u6784_u9020_u51FD_u6570__26amp_3B__u8BBE_u7F6E_u539F_u578B"><a href="#1-_u6700_u5E38_u7528_u7684_u7EE7_u627F_u7EC4_u5408_u6A21_u5F0F__u2014_u2014__u501F_u7528_u6784_u9020_u51FD_u6570__26amp_3B__u8BBE_u7F6E_u539F_u578B" class="headerlink" title="1.最常用的继承组合模式 —— 借用构造函数 &amp; 设置原型"></a>1.最常用的继承组合模式 —— 借用构造函数 &amp; 设置原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承Parent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 借用构造函数，只能继承父类this的属性</span></span><br><span class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置原型 继承父类this属性以及父类的原型</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<p>缺点：父构造函数被调用了两次，从而导致同一个属性会被继承两次（this.name）</p>
<h3 id="2-__u5171_u4EAB_u539F_u578B"><a href="#2-__u5171_u4EAB_u539F_u578B" class="headerlink" title="2. 共享原型"></a>2. 共享原型</h3><p>在上面的模式当中，<code>Child.prototype = new Parent();</code> 其实是有缺陷的。</p>
<ol>
<li>继承了父类自身的属性</li>
<li>继承了父类的原型属性(方法)</li>
</ol>
<p>基于上面的问题，如果 <code>Child.prototype</code> 不指向 Parent的实例 <code>new Parent()</code>，而是指向 <code>Parent.prototype</code> 的话，那么问题就可以解决了。</p>
<p>但是，如果直接共享原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure></p>
<p>这样很明显是有问题的，因为对Child原型的修改，会影响到所有对象和祖先对象！</p>
<h3 id="3-__u4E34_u65F6_uFF08_u4EE3_u7406_uFF09_u6784_u9020_u51FD_u6570"><a href="#3-__u4E34_u65F6_uFF08_u4EE3_u7406_uFF09_u6784_u9020_u51FD_u6570" class="headerlink" title="3. 临时（代理）构造函数"></a>3. 临时（代理）构造函数</h3><p>要想实现 2.共享原型 的理念，而又不出现上面的问题，则需要<strong>切断父对象和子对象原型的直接链接关系</strong>。</p>
<p>所以<strong>实现方式</strong>是：声明一个空白的函数，用这个空白函数充当子对象和父对象之间的代理。</p>
<p><strong>类式继承的圣杯模式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 空白的代理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理函数与父原型建立直接链接关系</span></span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为F函数是空白的，所以也不存在模式1当中的问题</span></span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修正constructor指向（此修复会使得constructor变成可枚举）</span></span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-__u603B_u7ED3"><a href="#4-__u603B_u7ED3" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>根据上述1~3，可以总结出以下的继承模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承Parent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 借用构造函数，只能继承父类this的属性</span></span><br><span class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 3.代理构造函数</span></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 3.代理构造函数 等价 【Object.create 实现见下面】</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br></pre></td></tr></table></figure></p>
<h2 id="u539F_u578B_u7EE7_u627F"><a href="#u539F_u578B_u7EE7_u627F" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型继承并不涉及到类，这里的对象都是继承自其他对象。</p>
<p>其实指的就是ES5里面的 <code>Object.create()</code> 方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">    name: <span class="string">"dad"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// "dad"</span></span><br></pre></td></tr></table></figure></p>
<p>以下是 <code>Object.create()</code> 方法的polyfill<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###通过复制属性实现继承 —— 浅复制 &amp; 深复制</p>
<p>继承的目的是为了实现代码复用，所以一个对象要从另一个对象中获取功能，把目标对象的属性和方法复制过来也是一种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend(child, parent);</span><br><span class="line"><span class="comment">// 这时，child对象就具有parent对象的属性和方法，即被扩展（extend）了</span></span><br></pre></td></tr></table></figure></p>
<p>####浅复制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.hasOwnProperty(key)) &#123;</span><br><span class="line">            child[key] = parent[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####深复制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                child[key] <span class="built_in">Object</span>.prototype.toString.call(parent[key]) === <span class="string">'[object Array]'</span> ? [] : &#123;&#125;;</span><br><span class="line">                cloneDeep(parent[key], child[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                child[key] = parent[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在《javascript模式》一书中，把继承分为了<strong>类式继承</strong>和<strong>原型继承</strong>，以下是对这部分的一个总结。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/tags/javascript/"/>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数curry化(Haskell Curry)]]></title>
    <link href="http://zhangfengqi.xyz/2015/07/12/javascript/%E5%87%BD%E6%95%B0curry%E5%8C%96/"/>
    <id>http://zhangfengqi.xyz/2015/07/12/javascript/函数curry化/</id>
    <published>2015-07-11T16:00:00.000Z</published>
    <updated>2015-07-11T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>个人白话文对curry化的解释：<strong>“当一个函数fn有多个参数时，可以先传入一部分参数，生成一个中继函数nextFn，然后在nextFn当中再传入剩下的参数。（一步curry化）。”</strong> 看完curry化，第一个感觉是好高大阿，但是…好像目前没感觉到它有什么用耶。。。然而你并不知道什么时候就会用到它！<br><a id="more"></a></p>
<h2 id="u4EC0_u4E48_u662F_u51FD_u6570curry_u5316_uFF1F"><a href="#u4EC0_u4E48_u662F_u51FD_u6570curry_u5316_uFF1F" class="headerlink" title="什么是函数curry化？"></a>什么是函数curry化？</h2><blockquote>
<p><strong>官方解释</strong><br>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<!-- more -->
<p><strong>个人白话文理解</strong></p>
<p>当一个函数fn有多个参数时，可以先传入一部分参数，生成一个中继函数nextFn，然后在nextFn当中再传入剩下的参数。（一步curry化）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> y == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nextFn = currying(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(nextFn(<span class="number">5</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u901A_u7528curry_u5316_u51FD_u6570"><a href="#u901A_u7528curry_u5316_u51FD_u6570" class="headerlink" title="通用curry化函数"></a>通用curry化函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="comment">// 将arguments对象数组化，并排除第一个参数fn</span></span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newArgs = slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args.concat(newArgs));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一步curry化</span></span><br><span class="line"><span class="keyword">var</span> next = currying(add, <span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line"><span class="comment">// 两步curry化</span></span><br><span class="line"><span class="keyword">var</span> next2 = currying(next, <span class="number">33</span>);</span><br><span class="line"><span class="comment">// 三步curry化</span></span><br><span class="line"><span class="keyword">var</span> next3 = currying(next2, <span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">next(<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>); <span class="comment">// 165</span></span><br><span class="line">next2(<span class="number">44</span>, <span class="number">55</span>); <span class="comment">// 165</span></span><br><span class="line">next3(<span class="number">55</span>); <span class="comment">// 165</span></span><br></pre></td></tr></table></figure>
<h2 id="curry_u5316_u6709_u4EC0_u4E48_u7528"><a href="#curry_u5316_u6709_u4EC0_u4E48_u7528" class="headerlink" title="curry化有什么用"></a>curry化有什么用</h2><p>参照：<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">http://www.zhangxinxu.com/wordpress/2013/02/js-currying/</a></p>
<h4 id="1-__u53C2_u6570_u590D_u7528"><a href="#1-__u53C2_u6570_u590D_u7528" class="headerlink" title="1. 参数复用"></a>1. 参数复用</h4><p>curry化之后会返回一个新的函数，这个函数通过闭包保存着重复的参数。</p>
<h4 id="2-__u5EF6_u8FDF_u6267_u884C"><a href="#2-__u5EF6_u8FDF_u6267_u884C" class="headerlink" title="2. 延迟执行"></a>2. 延迟执行</h4><p>其实ES5当中的<code>Function.prototype.bind</code>方法运用的就是curry化的思想<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.bind == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> newArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> me.apply(o, args.concat(newArgs));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>看完curry化，第一个感觉是好高大阿，但是…好像目前没感觉到它有什么用耶。。。</p>
<p>其实我觉得张鑫旭的博客<a href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/" target="_blank" rel="external">JS中的柯里化</a>当中，有段话讲的挺有道理的</p>
<blockquote>
<p>最近在看《JavaScript模式》一书，天哪，里面出现的各种设计模式（如工厂模式、外观模式、观察者模式），一双手都数不过来。而且这些名词又很抽象，书一合，马上大眼瞪小眼了。这种感觉就像是，房间里来了10个黑人，每个黑人都有一个“￥%#…￥”的名字，好不容易勉强记住了，灯一关房间一黑，等再开灯的时候，每个黑人的名字都变成…..”hello”了。</p>
<p>其实这些模式在实际使用的时候，或多或少都使用过，当看到“xx模式”概念的时候，我们就会猛然惊起：“哦，原来这个就叫做‘观察者模式’等”。现在要讨论的问题是，我们有没有必要把这些“xx模式”都记住呢，都理解其对应的核心呢？</p>
<p>这个问题类似于，我可以看懂NBA的篮球比赛，那我有没有必要把各个球队以及球队的队员都记住呢？<br>如果想成为JS大神，从这个目标来看，这是需要的；好比优秀的篮球解说员必须要知道每个球队的名字、球员甚至周边八卦。但是，现实很重要。如果连JS函数相关的基本东西都驾驭不好，显然，硬是啃这些似懂非懂的概念只会造成混乱。如果你觉得可以更近一步，先通透几个自己习惯的熟悉的使用模式，足够应付实际项目；其他一些概念什么的，更多的只是噱头，实用性其实并不大。</p>
<p>正如本文的柯里化，看上去很高级，似乎也有点用处，然而JS的灵活性使得很多实现完全摆脱“柯里化”这个概念的束缚，以更通俗易懂的方式实现。<br>然而，即使实用性不高，我们还是要有所了解，因为，你不知道什么时候会用到它。比方说CSS中的 <code>display:table;</code> 某些情况下可以解决一些棘手问题(secret!)。</p>
<p>因此，本文的柯里化至少要知道个大概…</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>个人白话文对curry化的解释：<strong>“当一个函数fn有多个参数时，可以先传入一部分参数，生成一个中继函数nextFn，然后在nextFn当中再传入剩下的参数。（一步curry化）。”</strong> 看完curry化，第一个感觉是好高大阿，但是…好像目前没感觉到它有什么用耶。。。然而你并不知道什么时候就会用到它！<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/tags/javascript/"/>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[清除浮动的几种方法]]></title>
    <link href="http://zhangfengqi.xyz/2015/04/16/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://zhangfengqi.xyz/2015/04/16/清除浮动的几种方法/</id>
    <published>2015-04-15T16:00:00.000Z</published>
    <updated>2015-04-15T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>感觉现阶段清除浮动的方式主要利用的是 <code>clear:both</code> 和 <code>overflow:auto||hidden||scroll</code> 这两个css属性，只不过利用上述两者的实现方式有所不同而已。<br><a id="more"></a></p>
<h3 id="u5229_u7528_clear_3Aboth__u6E05_u9664_u6D6E_u52A8"><a href="#u5229_u7528_clear_3Aboth__u6E05_u9664_u6D6E_u52A8" class="headerlink" title="利用 clear:both 清除浮动"></a><strong>利用 <code>clear:both</code> 清除浮动</strong></h3><p><strong>1.<code>clear:both</code> + 多余的标签</strong></p>
<pre><code>`&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;`
</code></pre><p>将以上div放在浮动元素父级的内部<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.clear1</span> <span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value">block</span></span>; <span class="comment">/* 对内联元素使用clear无效 */</span></span><br><span class="line">	<span class="rule"><span class="attribute">clear</span>:<span class="value">both</span></span>;</span><br><span class="line">	<span class="comment">/* 以下属性估计是为了避免标签中有文本或图片内容显示出来而造成影响 */</span></span><br><span class="line">	<span class="rule"><span class="attribute">line-height</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">overflow</span>:<span class="value">hidden</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>缺点</strong>：要添加多余的无意义标签</p>
<p><strong>2.<code>clear:both</code> + 伪类</strong></p>
<p>同样将此类名添加在浮动元素的父级身上<br>与<code>1.</code>相比，是将伪类去替代<code>div</code>，感觉本质还是没变<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.Clear2</span><span class="pseudo">:after</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">content</span>:<span class="value"><span class="string">'.'</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">display</span>:<span class="value">block</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">0</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">clear</span>:<span class="value">both</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">overflow</span>:<span class="value">hidden</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">visibility</span>:<span class="value">hidden</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="comment">/*伪类在IE67中无法识别*/</span></span><br><span class="line"><span class="comment">/*IE67是因为用了zoom:1触发hasLayout才清的浮动*/</span></span><br><span class="line"><span class="class">.Clear2</span> <span class="rules">&#123;<span class="rule"><span class="attribute">zoom</span>:<span class="value"><span class="number">1</span></span></span>;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ps.</strong> 如果IE67下，浮动元素父级具有width值(非auto)，是不需要清除浮动的。因为width已经触发了haslayout。</p>
<h3 id="u5229_u7528_overflow__u6E05_u9664_u6D6E_u52A8"><a href="#u5229_u7528_overflow__u6E05_u9664_u6D6E_u52A8" class="headerlink" title="利用 overflow 清除浮动"></a><strong>利用 <code>overflow</code> 清除浮动</strong></h3><p>其实第一次看到可以用 <code>overflow</code> 清除浮动(其实我是拒绝的)，有一种很神奇的感觉，为什么这样可以清除浮动？！而这样的问题，也作为面试题被问过。</p>
<p>而其原因在于，<code>overflow(非visible值)</code> 可以触发 BFC(Block Formatting Context) 或者是 IE67中的 <code>hasLayout</code>，使之改变了排版的方式。</p>
<p>那问题又来了，什么是BFC，什么是 <code>hasLayout</code>?</p>
<p>关于 <code>hasLayout</code> 请戳<a href="http://riny.net/2013/haslayout/" target="_blank" rel="external">这里</a>，解释的蛮清晰的。</p>
<blockquote>
<p>####<strong>什么是BFC</strong><br>BFC（Block Formatting Context）直译为“块级格式化范围”，是 W3C CSS 2.1 规范中的一个概念，它<strong>决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。</strong></p>
<p>####<strong>BFC的几大用处</strong></p>
<ol>
<li>防止margin折叠</li>
<li>清除浮动</li>
<li>不会环绕浮动元素<br>####<strong>BFC的特点</strong></li>
<li>形成独立的空间，对内部元素负责，隔离内部元素对外界的影响。</li>
<li>自身对外界表现正常</li>
<li>不会覆盖float元素，并且自适应的占据这一行剩下的宽度<br>####<strong>如何触发BFC</strong></li>
</ol>
<ul>
<li>使用 float，并且值不为 none</li>
<li>使用 absolute 定位的元素</li>
<li><strong>使用 overflow,并且值不为 visible</strong></li>
<li>使用 display: table-cell / table-caption / inline-block</li>
<li>使用 position, 并且值不为 static / relative</li>
</ul>
<p><strong>资料</strong><br><a href="http://outofmemory.cn/wr/?u=http%3A%2F%2Fkkeys.me%2Fpost%2F68547473290" target="_blank" rel="external">Block Formatting Context In CSS</a><br><a href="http://www.cnblogs.com/pigtail/archive/2013/01/23/2871627.html" target="_blank" rel="external">关于Block Formatting Context</a></p>
</blockquote>
<p> 以上资料说明，只要能触发 BFC 或者 <code>hasLayout</code> 的css属性均可以清除浮动，而 <code>overflow</code> 被广泛使用的原因，我想应该在于，在触发 BFC 或者 <code>hasLayout</code> 的同时，对元素自身的定位或者表现影响有限。</p>
<p>下面是对使用 <code>overflow</code> 的几个属性值来清除浮动时，它们之间的差异性。</p>
<p>参考：<a href="http://www.quirksmode.org/css/clearing.html" target="_blank" rel="external">http://www.quirksmode.org/css/clearing.html</a><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.container</span><span class="rules">&#123;</span><br><span class="line">	<span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#ccc</span></span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">overflow</span>:<span class="value"> auto</span></span>;</span><br><span class="line">	<span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>以上使用的是<code>overflow:auto</code>，下面几点值得我们注意：</p>
<p><strong>1.</strong> 使用除了 <code>overflow</code> 的默认值 <code>visible</code> 以外的值<code>auto</code> <code>hidden</code> <code>scroll</code> 均可清除浮动。当然，使用 <code>scroll</code> 的话滚动条是会一直显示的。</p>
<p><strong>2.</strong>  在使用 <code>auto</code> 或者 <code>hidden</code> 时，需要保证容器的高度为自适应(即不显式定义height)；此外浮动元素的总宽度应该始终小于容器的宽度。否则，在清除了浮动的同时会带来另外的问题：超出容器部分的内容会被“切”掉，或者出现滚动条。</p>
<p><strong>3.</strong> 在Explorer Mac中，设置 <code>auto</code> 会始终显示滚动条。（不懂mac 没测过）</p>
<p><strong>4.</strong> 对于IE6，设置 <code>overflow</code> 并不能触发 <code>hasLayout</code>, （IE7可以！）因此需要设置其他属性，如<code>zoom:1</code> <code>width: 100%</code> 等。</p>
<h3 id="u4EE5_u4E0B_u662F_u5176_u4ED6_u53EF_u4EE5_u6E05_u9664_u6D6E_u52A8_u7684_u65B9_u6CD5_uFF0C_u4F46_u6709_u5F88_u5927_u5C40_u9650_u6027_u6216_u517C_u5BB9_u95EE_u9898_uFF0C_u56E0_u6B64_u4E0D_u5E38_u7528"><a href="#u4EE5_u4E0B_u662F_u5176_u4ED6_u53EF_u4EE5_u6E05_u9664_u6D6E_u52A8_u7684_u65B9_u6CD5_uFF0C_u4F46_u6709_u5F88_u5927_u5C40_u9650_u6027_u6216_u517C_u5BB9_u95EE_u9898_uFF0C_u56E0_u6B64_u4E0D_u5E38_u7528" class="headerlink" title="以下是其他可以清除浮动的方法，但有很大局限性或兼容问题，因此不常用"></a><strong>以下是其他可以清除浮动的方法，但有很大局限性或兼容问题，因此不常用</strong></h3><ol>
<li><p>让浮动元素的父级也跟着浮动起来，<code>float:left</code> or <code>float:right</code></p>
</li>
<li><p>为浮动元素的父级添加<code>display:inline-block</code></p>
</li>
<li><p>为浮动元素的父级添加<code>position:absolute</code></p>
<p><strong>不难看出，以上方法的目的都是为了触发BFC或者 <code>hasLayout</code>。</strong></p>
</li>
</ol>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>从各种书籍和文章看来，清除浮动主要是从以下两种思路入手：</p>
<ol>
<li>利用 <code>clear</code> 属性</li>
<li>触发BFC 或者 <code>hasLayout</code></li>
</ol>
<p>以上是对最近看到的有关清除浮动的资料，所做的思考总结。如理解有误，有望指出~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>感觉现阶段清除浮动的方式主要利用的是 <code>clear:both</code> 和 <code>overflow:auto||hidden||scroll</code> 这两个css属性，只不过利用上述两者的实现方式有所不同而已。<br>]]>
    
    </summary>
    
      <category term="css" scheme="http://zhangfengqi.xyz/tags/css/"/>
    
      <category term="CSS" scheme="http://zhangfengqi.xyz/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js的自定义事件]]></title>
    <link href="http://zhangfengqi.xyz/2015/01/25/javascript/js%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"/>
    <id>http://zhangfengqi.xyz/2015/01/25/javascript/js自定义事件/</id>
    <published>2015-01-24T16:00:00.000Z</published>
    <updated>2015-01-24T16:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>js中的自定义事件机制的原理模拟（pub-sub）<br><a id="more"></a></p>
<h2 id="jquery_u4E2D_u7684_u81EA_u5B9A_u4E49_u4E8B_u4EF6"><a href="#jquery_u4E2D_u7684_u81EA_u5B9A_u4E49_u4E8B_u4EF6" class="headerlink" title="jquery中的自定义事件"></a>jquery中的自定义事件</h2><p>在jquery中，我们可以通过 <code>on</code>方法进行自定义事件的注册</p>
<p>通过<code>trigger</code>方法触发已注册的自定义事件<br><!--more--><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">'msg'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a msg for '</span> + name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).trigger(<span class="string">'msg'</span>, <span class="string">'zhangfengqi'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u5B9A_u4E49_u4E8B_u4EF6_u5B9E_u73B0_u673A_u5236_u7684_u6A21_u62DF"><a href="#u81EA_u5B9A_u4E49_u4E8B_u4EF6_u5B9E_u73B0_u673A_u5236_u7684_u6A21_u62DF" class="headerlink" title="自定义事件实现机制的模拟"></a>自定义事件实现机制的模拟</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存放事件队列</span></span><br><span class="line">    <span class="comment">// &#123;事件名: [fn, fn, fn], 事件名2: [fn, fn, fn]&#125;</span></span><br><span class="line">    <span class="keyword">var</span> events = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.events = events;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 自定义事件注册</span><br><span class="line"> * @params &#123;String&#125;   name 事件名</span><br><span class="line"> * @params &#123;Function&#125; fn   注册函数</span><br><span class="line"> */</span></span><br><span class="line">Event.prototype.on = <span class="function"><span class="keyword">function</span> (<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.events[name]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.events[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理存在同名事件的情况</span></span><br><span class="line">    <span class="keyword">this</span>.events[name].push(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 自定义事件触发fire</span><br><span class="line"> * @params &#123;String&#125; name 事件名</span><br><span class="line"> * @params &#123;...*&#125;   args 要传入的参数 个数不限</span><br><span class="line"> */</span></span><br><span class="line">Event.prototype.trigger = Event.prototype.fire =  <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ev = <span class="keyword">this</span>.events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ev[name]) &#123;</span><br><span class="line">        <span class="comment">// 存储除了事件名以外的所有参数</span></span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">var</span> fns = ev[name];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次执行事件队列中的函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">            fns[i].apply(<span class="literal">null</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 注销自定义事件</span><br><span class="line"> * @params &#123;String&#125; name 事件名</span><br><span class="line"> */</span></span><br><span class="line">Event.prototype.off = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.events[name]) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.events[name];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event();</span><br><span class="line">ev.on(<span class="string">'msg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ev.on(<span class="string">'msg'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'secondEvent:'</span>+ a, b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ev.emit(<span class="string">'msg'</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>js中的自定义事件机制的原理模拟（pub-sub）<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/tags/javascript/"/>
    
      <category term="javascript" scheme="http://zhangfengqi.xyz/categories/javascript/"/>
    
  </entry>
  
</feed>
