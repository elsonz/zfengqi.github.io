<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> js继承 · 返屋企的技术宅</title><meta name="description" content="在《javascript模式》一书中，把继承分为了类式继承和原型继承，以下是对这部分的一个总结。
类式继承&lt;a href=&quot;#1-_u6700_u5E38_u7528_u7684_u7EE7_u627F_u7EC4_u5408_u6A21_u5F0F__u2014_u2014__u501F_u7528_u6784_u9020_u51FD_u6570__26amp_3B__u8BBE_u7F6E_u539F_u578B&quot; class=&quot;headerlink&quot; title=&quot;1.最常用的继承组合模式 —— 借用构造函数 &amp;amp; 设置原型&quot;"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header style="background-image:url(/header-bg.jpg)"><a href="/" class="logo-link"><img src="/avatar.jpeg"></a><p class="info">zhangfengqi</p><p class="profession"><span>tobe 靠谱的 Front-End Developer</span></p><p class="motto">stay curious · stay hungry</p><nav><ul id="navigation"><li><a href="/archives">归档</a></li><li><a href="/about">关于我</a></li></ul></nav><ul class="sn sn-list iconfont"><li class="sn-list-item"><a href="http://weibo.com/jaredzfq" target="_blank" class="sn-list-link icon-weibo"></a></li><li class="sn-list-item"><a href="https://github.com/zfengqi" target="_blank" class="sn-list-link icon-github"></a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">js继承</h1><div class="post-meta"><div class="post-time">2015年07月12日</div></div><div class="post-content"><p>在《javascript模式》一书中，把继承分为了<strong>类式继承</strong>和<strong>原型继承</strong>，以下是对这部分的一个总结。<br><a id="more"></a></p>
<h2 id="u7C7B_u5F0F_u7EE7_u627F"><a href="#u7C7B_u5F0F_u7EE7_u627F" class="headerlink" title="类式继承"></a>类式继承</h2><h3 id="1-_u6700_u5E38_u7528_u7684_u7EE7_u627F_u7EC4_u5408_u6A21_u5F0F__u2014_u2014__u501F_u7528_u6784_u9020_u51FD_u6570__26amp_3B__u8BBE_u7F6E_u539F_u578B"><a href="#1-_u6700_u5E38_u7528_u7684_u7EE7_u627F_u7EC4_u5408_u6A21_u5F0F__u2014_u2014__u501F_u7528_u6784_u9020_u51FD_u6570__26amp_3B__u8BBE_u7F6E_u539F_u578B" class="headerlink" title="1.最常用的继承组合模式 —— 借用构造函数 &amp; 设置原型"></a>1.最常用的继承组合模式 —— 借用构造函数 &amp; 设置原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承Parent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 借用构造函数，只能继承父类this的属性</span></span><br><span class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置原型 继承父类this属性以及父类的原型</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<p>缺点：父构造函数被调用了两次，从而导致同一个属性会被继承两次（this.name）</p>
<h3 id="2-__u5171_u4EAB_u539F_u578B"><a href="#2-__u5171_u4EAB_u539F_u578B" class="headerlink" title="2. 共享原型"></a>2. 共享原型</h3><p>在上面的模式当中，<code>Child.prototype = new Parent();</code> 其实是有缺陷的。</p>
<ol>
<li>继承了父类自身的属性</li>
<li>继承了父类的原型属性(方法)</li>
</ol>
<p>基于上面的问题，如果 <code>Child.prototype</code> 不指向 Parent的实例 <code>new Parent()</code>，而是指向 <code>Parent.prototype</code> 的话，那么问题就可以解决了。</p>
<p>但是，如果直接共享原型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = Parent.prototype;</span><br></pre></td></tr></table></figure></p>
<p>这样很明显是有问题的，因为对Child原型的修改，会影响到所有对象和祖先对象！</p>
<h3 id="3-__u4E34_u65F6_uFF08_u4EE3_u7406_uFF09_u6784_u9020_u51FD_u6570"><a href="#3-__u4E34_u65F6_uFF08_u4EE3_u7406_uFF09_u6784_u9020_u51FD_u6570" class="headerlink" title="3. 临时（代理）构造函数"></a>3. 临时（代理）构造函数</h3><p>要想实现 2.共享原型 的理念，而又不出现上面的问题，则需要<strong>切断父对象和子对象原型的直接链接关系</strong>。</p>
<p>所以<strong>实现方式</strong>是：声明一个空白的函数，用这个空白函数充当子对象和父对象之间的代理。</p>
<p><strong>类式继承的圣杯模式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 空白的代理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理函数与父原型建立直接链接关系</span></span><br><span class="line">    F.prototype = Parent.prototype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为F函数是空白的，所以也不存在模式1当中的问题</span></span><br><span class="line">    Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修正constructor指向（此修复会使得constructor变成可枚举）</span></span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-__u603B_u7ED3"><a href="#4-__u603B_u7ED3" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>根据上述1~3，可以总结出以下的继承模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 继承Parent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 借用构造函数，只能继承父类this的属性</span></span><br><span class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 3.代理构造函数</span></span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 3.代理构造函数 等价 【Object.create 实现见下面】</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br></pre></td></tr></table></figure></p>
<h2 id="u539F_u578B_u7EE7_u627F"><a href="#u539F_u578B_u7EE7_u627F" class="headerlink" title="原型继承"></a>原型继承</h2><p>原型继承并不涉及到类，这里的对象都是继承自其他对象。</p>
<p>其实指的就是ES5里面的 <code>Object.create()</code> 方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">    name: <span class="string">"dad"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// "dad"</span></span><br></pre></td></tr></table></figure></p>
<p>以下是 <code>Object.create()</code> 方法的polyfill<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###通过复制属性实现继承 —— 浅复制 &amp; 深复制</p>
<p>继承的目的是为了实现代码复用，所以一个对象要从另一个对象中获取功能，把目标对象的属性和方法复制过来也是一种方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend(child, parent);</span><br><span class="line"><span class="comment">// 这时，child对象就具有parent对象的属性和方法，即被扩展（extend）了</span></span><br></pre></td></tr></table></figure></p>
<p>####浅复制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.hasOwnProperty(key)) &#123;</span><br><span class="line">            child[key] = parent[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####深复制<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                child[key] <span class="built_in">Object</span>.prototype.toString.call(parent[key]) === <span class="string">'[object Array]'</span> ? [] : &#123;&#125;;</span><br><span class="line">                cloneDeep(parent[key], child[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                child[key] = parent[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="update-time">更新于：2016年01月10日</div></article></div><div class="side-bar"><div class="widget"><h3 class="widget-title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/基础/">基础</a></li></ul></div><div class="widget"><h3 class="widget-title">标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工具/">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul></div></div></section><footer><div class="paginator"><a href="/2015/09/05/数据库基础/" class="prev">上一篇</a><a href="/2015/07/12/javascript/函数curry化/" class="next">下一篇</a></div><div class="copyright"><p>© 2015-2016<span>zhangfengqi.xyz</span></p><span class="theme">Theme based on <a href="https://github.com/pinggod/hexo-theme-apollo" class="theme-url">appolo</a></span><span class="hexo">Powered by <a href="https://hexo.io/">Hexo</a></span></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>